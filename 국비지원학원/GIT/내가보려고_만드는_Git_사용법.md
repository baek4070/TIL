학원을 다니면서 배운내용들을 꾸준히 커밋하리라는 목표를 가지고 Git 튜토리얼 여러 영상과 블로그를 참조해서 대략적인 사용법을 익힌후 지금 까지 내맘대롷 사용중이다. 혼자만 사용하는 저장소이다 보니 git의 기능을 원격 usb 정도로만 사용하는 내모습이 안타깝기도 하고  중간중간 문제가 발생할때마다 못본채 무시 하거나 구글링해서 -f 로 강제 push를 한다던지 비정상(?)적인 방법으로  해결하곤 하는 나를 좀 디벨롭 시키고자 해당 포스트를 작성한다.

이글은 [https://git-scm.com/book/ko/v2](https://git-scm.com/book/ko/v2)  한글번역본을 참조해 작성하였다

Git의 모든 기능을 지원하는 것은 CLI 뿐이므로 GIT BASH 를 이용한 CLI기준으로 설명 하겠다

## 버전관리

- VCS(Version Control System)
    
    Git을 사용하는 목적이라고 생각하면 된다 버전관리란 자료의 백업,협업,변경상태 등 아무튼 엄청 파워풀한 기능이다
    
    - 로컬버전관리
        
        그냥 이러게 있다 정도로만 알아두자 우리의 목표는 Git 이니까
        
    - 중앙집중식 버전관리(CVCS)
        
        중앙서버에 문제가 생기면 프로젝트의 거의모든 히스토리를 잃는다. 이는 로컬 VCS도 마찬가지이다
        
        - Subversion
        - Perforce
        - CVS
    - 분산버전 관리(DVCS)
        
        클라이언트나 서버나 프로젝트의 히스토리를 포함한 전부를 복제하여 각자 저장소에 저장하고 있는 시스템(서버,각자 클라이언트)
        
        - Git //Git은 분산버전 관리시스템이다
        - Mecurial
        - Bazaar
        - Darcs 등등..

## Git이 추구하는 목표

- 빠른속도
- 단순한 구조
- 비선형적인 개발
- 완벽한 분산
- 대형프로젝트에서도 유용할 것(속도나 데이터 크기면에서)

Git은 동시다발적인 브랜치에도 끄떡없는 슈퍼 울트라 브랜칭 시스템이라고 합니다

## Git의 핵심

- Git은 데이터를 스냅샷의 스트림 처럼 취급한다
    
    이게 뭔말인가 하면 파일의 모든 상태들을 저장하는것이 아니고 이전 상태의 파일에 대한 링크만 저장하는 (마치 변경된부분만 사진찍어 남겨두는)이해는 가지만 설명하긴 어려운 개념 , 이러한 점이 Git이 다른VSC보다 좋은 성능을 가질수있는  핵심요소이다
    
- 거의 모든 명령을 로컬에서 실행
    
    거의 모든 명령이 로컬에서 실행되며 프로젝트의 모든 히스토리를 로컬에 저장하기 때문에  네트워크의 영향을 받지않아 속도가 빠르며 어떤 공간과 상황에 따른 제약이 적은편이다. 다른 VCS에선 네트워크를 통한 데이터 베이스 접근없이는 거의 할수있는게 없다고 한다.  
    
- Git의 무결성(무결성이란 데이터 베이스에 값이 정확하다는 것을 의미한다. 항상 정확한 데이터를 유지하고 있다는 것을 의미, 그니까 Git의 데이터는 변하지않는다 Git은 믿을만하다는 뜻이다)
    
    Git은 SHA-1 해시를 사용하여 40자길이의 16진수 문자열 체크섬을 만들어 저장한다. 이는 Git에서 사용하는 가장작은 데이터 단위 이며 모든것을 해시로 식별하고 파일 이름을 해당 파일의 해시로 저장한다.
    
- Git은 데이터를 추가할 뿐
    
    Git으로 무얼 하든 Git 데이터베이스에 데이터가 추가되는 개념이다. 되돌리거나 데이터를 삭제하는것이 아니다
    
- 세 가지 상태(아직은 몰라도 뒤에서 이해할수 있다)
    - Committed : 데이터가 로컬 데이터베이스에 안전하게 저장됐다는 것을 의미
        - Repository 에 올려둔 상태
        - Staging Area에 있는 파일들을 커밋해서 Git 디렉토리에 영구적인 스냅샷으로 저장한다.
    - Modified : 수정한 파일을 아직 로컬 데이터베이스에 커밋하지 않은 것을 의미
        - WorkingDirectory에 올려둔 상태
        - 워킹 트리에서 파일을 수정한다.
    - Staged : 현재 수정한 파일을 곧 커밋할 것이라고 표시한 상태를 의미
        - Staging Area에 올려둔 상태
        - Staging Area에 파일을 Stage 해서 커밋할 스냅샷을 만든다. 모든 파일을 추가할 수도 있고 선택하여 추가할 수도 있다.
- 설치하기
    
    그냥 검색해서 다운로드 하면된다 (별로 어려운것은 없다)
    
    다만 가장 최신버전이 필요하면 소스코드로 설치하는 것이 좋다(방법은 찾아보도록 하자)
    
    본인은 그냥 Git 검색해서 다운로드 했다
    

## 최초 설정 하기

Git을 설치하고 나면 Git의 사용 환경을 적절하게 설정해 주어야 한다. 한 컴퓨터에서 한 번만 하면 되고 언제든지 다시 바꿀 수 있다

git config라는 도구로 설정 내용을 확인하고 변경할 수 있다

- gitconfig 라는 설정 파일이 3개가 존재하는데 각각 해당 옵션으로 설정변경 가능하며 우선순위는 로컬이 가장높다
    - --system
    - --global
    - --local
- 사용자 정보 설정하기
    - git config --global user.name "깃허브 이름"
    - git config --global user.email 깃허브이메일
    - 이렇게 global옵션으로 딱한번만 설정하면 된다
    - 만약 프로젝트별로 다른 이름과 이메일 주소를 사용하고 싶으면 --global 옵션을 빼고 명령을 실행하면 된다 (로컬의 우선순위를 기억하라)
- Git에서 사용할 텍스트 편집기 고르기
    
    기본적으로 Git은 시스템의 기본편집기를 사용한다. 그래서 본인은 굳이 설정안했다(언젠가는 할지도)
    
    - git config --global core.editor emacs
        
        위와 같이 Emacs 라는 편집기 이용할수도 있다고 한다 ( 본인은 Emacs가 뭔지 모르겠다. 그냥 메모장 같은거겠지 라고 짐작할뿐)
        
    - Windows 사용자라면 다른 텍스트 편집기를 사용할 수 있다. 실행파일의 전체 경로를 설정해주면 된다. 실행파일의 전체 경로는 사용하는 편집기에 따라 다르다.
    - git config --global core.editor "'C:/Program Files/Notepad++/notepad++.exe' -multiInst -nosession"
    - git config --global core.editor "'C:/Program Files (x86)/Notepad++/notepad++.exe' -multiInst -nosession"
    - 위의 두가지 방법으로 Notepad++ 을 편집기로 등록가능 하다고 한다
- 설정 확인
    
    자 여러가지 설정했으니 이제 잘되었는지 확인해봐야한다
    
    - git config --list
    - 위의 명령어를 실행하면 설정한 모든것을 보여주어 확인할 수 있다.
    - user.name=baek4070
    user.email=baek4070@gmail.com
    
    이름과 이메일 설정할 당시 "" 을 포함하느냐 안하느냐 를 크로스 체크해보자
    
    - git config --global user.name "깃허브 이름" // "깃허브 이름" 인지 깃허브 이름 인지 헷갈림
    - git config --global user.email 깃허브이메일
    
    Git은 같은 키를 여러 파일(시스템, 글로벌, 로컬 등)에서 읽기 때문에 같은 키가 여러 개 있을 수도 있다. 그러면 Git은 나중 값을 사용한다.
    
    - git config <\key>
    - user.name=baek4070 이라하면 user.name 이 key값이다
    - ex) git config user.name
    
    git config <\key> 명령으로 Git이 특정 Key에 대해 어떤 값을 사용하는지 확인할 수 있다.
    

## Git 저장소 만들기

- 기존 디렉토리를 Git 저장소로 만드는 경우
1. 우선 프로젝트의 디렉토리로 이동한다.  
    
    cd 이동할경로
    
    cd /c/til
    
    뭐 이런식으로 이동한다
    
2. git init
    
    명령을 실행한다 
    
    그러면 .git이라는 하위 폴더가 생겼을 것이다. 여기에는 저장소에 필요한 뼈대파일이 들어있다
    
    이 명령만으로는 아직 프로젝트의 어떤 파일도 관리하지 않는다
    
    Git이 파일을 관리하게 하려면 저장소에 파일을 추가하고 커밋해야 한다. `git add` 명령으로 파일을 추가하고 `git commit` 명령으로 커밋한다
    
    `$ git add *.c
    $ git add LICENSE
    $ git commit -m 'initial project version'`
    
    그냥 형식이 이렇다는거다 꼭 이렇게 똑같이 입력할 필요는 없다
    
- 기존 저장소를 Clone 해오는 경우
    
    다른 프로젝트에 참여하려거나(Contribute) Git 저장소를 복사하고 싶을 때 git clone 명령을 사용한다. git clone 을 실행하면 프로젝트 히스토리를 전부 받아온다
    
    git clone <url> 명령으로 저장소를 Clone 한다.
    
    `libgit2` 라이브러리 소스코드를 Clone 하려면 아래과 같이 실행한다.
    
    `$ git clone https://github.com/libgit2/libgit2`
    
    이 명령은 `libgit2'' 라는 디렉토리를 만들고 그 안에`.git 디렉토리를 만든다. 그리고 저장소의 데이터를 모두 가져와서 자동으로 가장 최신 버전을 Checkout 해 놓는다
    
    아래과 같은 명령을 사용하여 저장소를 Clone 하면 `libgit2`이 아니라 다른 디렉토리 이름으로 Clone 할 수 있다.
    
    `$ git clone https://github.com/libgit2/libgit2 mylibgit`
    
    디렉토리 이름이 `mylibgit` 이라는 것만 빼면 이 명령의 결과와 앞선 명령의 결과는 같다.
    

## 수정하고 저장소에 저장하기

파일을 수정하고 파일의 스냅샷을 커밋해 보자. 파일을 수정하다가 저장하고 싶으면 스냅샷을 커밋한다.

- 워킹 디렉토리(작업공간 .git 이 생성되어있는곳) 의 모든파일은 크게 2가지 로 구분된다
    - Tracked(관리대상)
        - 이미 스냅샷에 포함돼있던 파일(commit을 한번이라도 한)
        - Tracked파일은 아래 3가지 상태중 하나이다(Git이 알고있는 파일이라는뜻)
        1. Unmodified(수정하지않음)
        2. Modified(수정함)
        3. Staged(커밋으로 저장소에 기록할)
    - Untracked(관리대상아님)
        
        Untracked 파일은 워킹 디렉토리에 있는 파일 중 스냅샷에도 Staging Area에도 포함되지 않은 파일
        
- 파일의 상태 확인하기
    
    파일의 상태를 확인하려면 보통 git status 명령을 사용한다.
    
    프로젝트 디렉토리에 cd로 이동한다음 git status 명령을 실행해보자
    
    git status 명령으로 확인할 수 있는 내용이 좀 많아 보일 수 있다.
    
    git status -s 또는 git status --short 처럼 옵션을 주면 현재 변경한 상태를 짤막하게 보여준다.
    
    - ?? : 아직 추적하지 않은 새파일
    - A : 새로 생성한 파일
    - M : 수정한 파일
    - 왼쪽에는 Staging Area에서의 상태를, 오른쪽에는 Working Tree에서의 상태를 표시
    
- 파일을 새로 추적하기
    
    git add 명령으로 파일을 새로 추적할 수 있다. 아래 명령을 실행하면 Git은 README 파일을 추적한다
    
    git add README
    
    git status 명령을 다시 실행하면 README 파일이 Tracked 상태이면서 커밋에 추가될 Staged 상태라는 것을 확인할 수 있다, `Changes to be committed'' 에 들어 있는 파일은 Staged 상태라는 것을 의미
    
    git add 명령은 파일 또는 디렉토리의 경로를 아규먼트로 받는다. 디렉토리면 아래에 있는 모든 파일들까지 재귀적으로 추가한다.
    
- Modified 상태의 파일을 Stage 하기
    
    git status 명령을 실행 했을때 'changes not staged for commit' 에 있으면 이건 수정한 파일이 추적은 되지만 staged 상태는 아니라는 것이다.Staged 상태로 만들려면 git add 명령을 실행해야 한다. 
    
    - git add 명령
        
        git add 명령은 파일을 새로 추적할 때도 사용하고 
        
        수정한 파일을 Staged 상태로 만들 때도 사용한다
        
         Merge 할 때 충돌난 상태의 파일을 Resolve 상태로 만들때도 사용한다
        
        add의 의미는 프로젝트에 파일을 추가한다기 보다는 다음 커밋에 추가한다고 받아들이자
        
        git add 명령을 실행하면 Git은 파일을 바로 Staged 상태로 만든다 지금 이 시점에서 커밋을 하면 git commit 명령을 실행하는 시점의 버전이 커밋되는 것이 아니라 마지막으로 git add 명령을 실행했을 때의 버전이 커밋된다.
        
- 파일 무시하기(아직 써볼일이 없어서 안써본 기능입니다)
    
    어떤 파일은 Git이 관리할 필요가 없다. 보통 로그 파일이나 빌드 시스템이 자동으로 생성한 파일이 그렇다. 그런 파일을 무시하려면 `.gitignore` 파일을 만들고 그 안에 무시할 파일 패턴을 적는다. 아래는 `.gitignore` 파일의 예이다.
    
    `$ cat .gitignore
    *.\[oa]
    *~`
    
    .gitignore 파일은 보통 처음에 만들어 두는 것이 편리하다. 그래서 Git 저장소에 커밋하고 싶지 않은 파일을 실수로 커밋하는 일을 방지할 수 있다
    
    - 아무것도 없는 라인이나, `#`로 시작하는 라인은 무시한다.
    - 표준 Glob 패턴을 사용한다. 이는 프로젝트 전체에 적용된다.
    - 슬래시(`/`)로 시작하면 하위 디렉토리에 적용되지(Recursivity) 않는다.
    - 디렉토리는 슬래시(`/`)를 끝에 사용하는 것으로 표현한다.
    - 느낌표(`!`)로 시작하는 패턴의 파일은 무시하지 않는다.
    
    ex)
    
    ```
    # 확장자가 .a인 파일 무시
    *.a
    
    # 윗 라인에서 확장자가 .a인 파일은 무시하게 했지만 lib.a는 무시하지 않음
    !lib.a
    
    # 현재 디렉토리에 있는 TODO파일은 무시하고 subdir/TODO처럼 하위디렉토리에 있는 파일은 무시하지 않음
    /TODO
    
    # build/ 디렉토리에 있는 모든 파일은 무시
    build/
    
    # doc/notes.txt 파일은 무시하고 doc/server/arch.txt 파일은 무시하지 않음
    doc/*.txt
    
    # doc 디렉토리 아래의 모든 .pdf 파일을 무시
    doc/**/*.pdf
    ```
    
    .gitignore 를 사용하는 간단한 방식중 하나는 .gitignore 파일을 최상위 디렉토리에 하나 두고 모든 하위 디렉토리에까지 적용시키는 방식이다.
    
- Staged 와 Unstaged 상태의 변경 내용을 보기
    
    단순히 파일이 변경됐다는 사실이 아니라 어떤 내용이 변경됐는지 살펴보려면 git status 명령이 아니라 git diff 명령을 사용해야 한다
    
    git diff 명령을 사용하는데 Patch처럼 어떤 라인을 추가했고 삭제했는지가 궁금할 때 사용한다
    
    git diff 명령을 실행하면  워킹 디렉토리에 있는 것과 Staging Area에 있는 것을 비교한다. 그래서 수정하고 아직 Stage 하지 않은 것을 보여준다.
    
    만약 커밋하려고 Staging Area에 넣은 파일의 변경 부분을 보고 싶으면 git diff --staged 옵션을 사용한다. 이 명령은 저장소에 커밋한 것과 Staging Area에 있는 것을 비교한다.
    
    Staged 상태인 파일은 git diff --cached 옵션으로 확인한다. --staged 와 --cached 는 같은 옵션이다.
    
    꼭 잊지 말아야 할 것이 있는데 git diff 명령은 마지막으로 커밋한 후에 수정한 것들 전부를 보여주지 않는다. git diff 는 Unstaged 상태인 것들만 보여준다. 수정한 파일을 모두 Staging Area에 넣었다면 git diff 명령은 아무것도 출력하지 않는다.
    
- 변경사항 커밋하기
    
    수정한 것을 커밋하기 위해 Staging Area에 파일을 정리했다. Unstaged 상태의 파일은 커밋되지 않는다는 것을 기억해야 한다. Git은 생성하거나 수정하고 나서 git add 명령으로 추가하지 않은 파일은 커밋하지 않는다. 그 파일은 여전히 Modified 상태로 남아 있다. 커밋하기 전에 git status 명령으로 모든 것이 Staged 상태인지 확인할 수 있다. 그 후에 git commit 을 실행하여 커밋한다.
    
    정확히 뭘 수정했는지도 보여줄 수 있는데, git commit 에 -v 옵션을 추가하면 편집기에 diff 메시지도 추가된다
    
    메시지를 인라인으로 첨부할 수도 있다. commit 명령을 실행할 때 아래와 같이 -m 옵션을 사용한다.
    
- Staging Area 생략하기
    
    git commit 명령을 실행할 때 -a 옵션을 추가하면 Git은 Tracked 상태의 파일을 자동으로 Staging Area에 넣는다. 그래서 git add 명령을 실행하는 수고를 덜 수 있다.
    
    a 옵션을 사용하면 모든 파일이 자동으로 추가된다. 편리한 옵션이긴 하지만 주의 깊게 사용해야 한다. 생각 없이 이 옵션을 사용하다 보면 추가하지 말아야 할 변경사항도 추가될 수 있기 때문이다.
    
- 파일 삭제하기
    
    Git에서 파일을 제거하려면 git rm 명령으로 Tracked 상태의 파일을 삭제한 후에(정확하게는 Staging Area에서 삭제하는 것) 커밋해야 한다. 이 명령은 워킹 디렉토리에 있는 파일도 삭제하기 때문에 실제로 파일도 지워진다.
    
    Git 명령을 사용하지 않고 단순히 워킹 디렉터리에서 파일을 삭제하고 git status 명령으로 상태를 확인하면 Git은 현재 ``Changes not staged for commit'' (즉, Unstaged 상태)라고 표시해준다.
    
    그리고 git rm 명령을 실행하면 삭제한 파일은 Staged 상태가 된다.
    
    커밋하면 파일은 삭제되고 Git은 이 파일을 더는 추적하지 않는다. 이미 파일을 수정했거나 Staging Area에(역주 - Git Index라고도 부른다) 추가했다면 `-f` 옵션을 주어 강제로 삭제해야 한다. 이 점은 실수로 데이터를 삭제하지 못하도록 하는 안전장치다. 커밋 하지 않고 수정한 데이터는 Git으로 복구할 수 없기 때문이다.
    
    또 Staging Area에서만 제거하고 워킹 디렉토리에 있는 파일은 지우지 않고 남겨둘 수 있다. 다시 말해서 하드디스크에 있는 파일은 그대로 두고 Git만 추적하지 않게 한다. 이것은 `.gitignore` 파일에 추가하는 것을 빼먹었거나 대용량 로그 파일이나 컴파일된 파일인 `.a` 파일 같은 것을 실수로 추가했을 때 쓴다. `--cached` 옵션을 사용하여 명령을 실행한다.
    
    $ git rm --cached README
    
    여러 개의 파일이나 디렉토리를 한꺼번에 삭제할 수도 있다. 아래와 같이 `git rm` 명령에 file-glob 패턴을 사용한다.
    
    `$ git rm log/\*.log`
    
    - `` 앞에 `\` 을 사용한 것을 기억하자. 파일명 확장 기능은 쉘에만 있는 것이 아니라 Git 자체에도 있기 때문에 필요하다. 이 명령은 `log/` 디렉토리에 있는 `.log` 파일을 모두 삭제한다. 아래의 예제처럼 할 수도 있다.
    
    `$ git rm \*~`
    
    이 명령은 `~` 로 끝나는 파일을 모두 삭제한다.
    
- 파일 이름 변경하기
    
    Git은 다른 VCS 시스템과는 달리 파일 이름의 변경이나 파일의 이동을 명시적으로 관리하지 않는다. 다시 말해서 파일 이름이 변경됐다는 별도의 정보를 저장하지 않는다. Git은 똑똑해서 굳이 파일 이름이 변경되었다는 것을 추적하지 않아도 아는 방법이 있다. 파일의 이름이 변경된 것을 Git이 어떻게 알아내는지 살펴보자.
    
    이렇게 말하고 Git에 `mv` 명령이 있는 게 좀 이상하겠지만, 아래와 같이 파일 이름을 변경할 수 있다.
    
    `$ git mv file_from file_to`
    
    잘 동작한다. 이 명령을 실행하고 Git의 상태를 확인해보면 Git은 이름이 바뀐 사실을 알고 있다.
    
    `$ git mv README.md README
    $ git status
    On branch master
    Your branch is up-to-date with 'origin/master'.
    Changes to be committed:
      (use "git reset HEAD <\file>..." to unstage)
    
        renamed:    README.md -> README`
    
    사실 `git mv` 명령은 아래 명령어를 수행한 것과 완전 똑같다.
    
    `$ mv README.md README
    $ git rm README.md
    $ git add README`
    
    `git mv` 명령은 일종의 단축 명령어이다. 이 명령으로 파일 이름을 바꿔도 되고 `mv` 명령으로 파일 이름을 직접 바꿔도 된다. 단지 `git mv` 명령은 편리하게 명령을 세 번 실행해주는 것 뿐이다. 어떤 도구로 이름을 바꿔도 상관없다. 중요한 것은 이름을 변경하고 나서 꼭 rm/add 명령을 실행해야 한다는 것 뿐이다.