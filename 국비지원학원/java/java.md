# Java

## Java API문서의 설치

- Java API란?

    -Java로 프로그램을 만드는데 필요한 주요 기능을 미리 만들어서 제공

- Java API문서란?

    -JavaAPI가 제공하는 기능에 대한 상세한 정보 제공(html파일)

- JavaAPI 문서의 설치

    -[여기](https://www.oracle.com/)에서 압축파일을 다운받아서 압축해제

## 이클립스에서 자바 프로그램을 작성하는 순서

1. 프로젝트를 생성한다
    * 메뉴 File>New>Java Project
2. 클래스를 생성한다.
    * 프로젝트 이름 위에서 우클릭 > New > Class
3. 소스파일의 작성 후 저장(자동 컴파일됨)
4. 실행
    * 메뉴 Run > Run

## Build 관련 메뉴 설명

- Build란?
    * 소스파일로부터 프로그램을 만들어 내는 전 과정
- Project > Build AII
    * workspace의 모든 프로젝트를 빌드
- Project > Build Project
    * 현재 프로젝트를 빌드(변경된 소스 파일만 새로 컴파일)
- Project > Clean
    * 이전 빌드의 정보를 모두 삭제(모든 소스 파일을 새로 컴파일)
    * 간혹가다 프로그램이 아무런 이유없이 실행되지 않을때 clean후 재컴파일
- Project > Build Automatically
    * 소스 파일을 변경 후, 저장할때마다 자동 컴파일

## 이클립스 기본 단축키

- ctrl + shift + l // 단축키 전체목록 보기
- ctrl + d // 한줄 삭제
- ctrl+ +,- // 폰트 크기 증가/감소
- ctrl + alt + down //행단위 복사
- alt + shift + A // 멀티 컬럼편집
- alt + up, down // 행단위 이동
- ctrl+i // 자동 들여쓰기
- ctrl + / // 주석 처리 (토글)
- ctrl + space // 자동완성

## 변수

1. 변수(variable)란?
    1. 하나의 값(데이터)을 저장할 수 있는 메모리 공간
2. 변수의 선언
    1. 변수의선언이유
        1. 값을 저장할 공간을 마련하기 위해서
    2. 변수의 선언 방법
        1. 변수타입 변수이름;
        2. ex) int age; //정수 타입의 변수 age를 선언
        3. age에 메모리 공간이 생성됨
3. 변수에 값 저장하기
    1. int age =25; // 정수 타입의 변수 age를 선언 하고 age에 25를 저장
    2. 변수의 초기화 // 변수에 처음으로 값을 저장하는것
        1. 지역 변수는 읽기전에 꼭 초기화 해야함!
4. 변수의 값 읽어오기 
    1. 변수의 값이 필요한 곳에 변수의 이름을 적는다
5. 변수의 이름 생성  // 변수 이름은 중복 불가
6. 변수의 타입
    1. int : 정수타입 , 여기에 실수 저장하려하면 에러남
    2. 변수의 타입은 저장할 값의 타입에 의해 결정된다
    3. 저장할 값의 타입과 일치하는 타입으로 변수를 선언
7. 값의 타입
    
    기본형//기본형을 제외한 나머지는 전부다 참조변수임
    
    1. 문자 : char : 2byte의 저장공간 65536가지의 값 표현
        1. 홑따옴표 = 한개의 문자 문자열
        2. 쌍따옴표 = 긴 문자열
    2. 숫자
        1. 정수 : 
            1. byte : 1byte의 저장 공간 -128 ~ 0 ~ 127
            2. short : 2byte의 저장공간 65536가지의 값 표현
            3. int : 4byte 정수
            4. long : 8byte 정수 8바이트 공간에 저장하라는 의미로 L을 붙임
        2. 실수 : 
            1. float : 소수점 7자리, 4바이트를 사용해도 충분한 실수인지 F를 붙임
            2. double : 소수점 15자리 - 실수 형 기본 리터럴
    3. 논리 : boolean 
        1. true : 1byte에 논리값을 저장
        2. false : 1byte에 논리값을 저장
    
    문자열 저장하는 녀석
    
    1. String : API CLASS 임, char type으로 저장됨, String 역시 참조변수
    2. new String("") : new라는 연산자는 heap에 동적으로 할당됨
8. 변수, 상수, 리터럴
    1. 상수(constant) : 한 번만 값을 저장 가능한 변수
    2. 리터럴(literal) : 그 자체로 값을 의미하는 것
9. 리터럴의 접두사와 접미사
    1. 논리형 
    2. 정수형
    3. 실수형
    4. 문자형
    5. 문자열
10. 문자와 문자열
    1. 

 

## 주석과 실행문

- 주석문 : 프로그램 실행과는 상관없이 코드에 설명 붙인것, 컴파일 과정에서 주석은 무시되고 실행문만 바이트 코드로 번역
    - // : 행주석
    - /* ~ */ : 범위 주석
- 실행문 : 변수 선언 값 저장 , 메소드 호출에 해당하는 코드 실행문 끝에는 반드시 세미콜론(;)을 붙여 실행문의 끝 표시

## 단항 연산자

- 단항연산자 : 피연산자가 1개인 연산자
    - 부호 연산자 : +, - //boolean 타입과 char 타입을 제외한 기본타입에 사용 가능 , 부호 연산자의 산출 타입은 int
    - 증감 연산자 : ++, — // 변수의 값을 1증가 시키거나 1감소 시키는 연산자, 증감 연산자가 변수 뒤에 있으면 다른 연산자 먼저 처리 후 증감 연산자 처리
    - 논리 부정 연산자 : ! // Boolean type 에만 사용가능

## 산술 연산자

- 산술 연산자 : +, -, *, /, %
- 문자열 연산자 : 피연산자중 문자열이 있으면 문자열로 결합 // 연산은  기본적으로 좌측부터 우측으로 진행 // 대입연산은 우측에서 좌측으로 진행
- 비교 연산자 : 동등 비교연산자는 모든 타입에 사용 가능 , 크기 비교 연산자는 boolean 타입 제외한 모든 기본타입에 사용 가능, 제어문인 조건문(if), 반복문(for, while)에서 주로 이용
    - ==, !=, > , >=, <, <=
    - 기본적으로 stack에 있는 값을 비교하기 때문에 주의하자
- 논리 연산자
    - &&, ||, ^, ! : 좌측에서 이미 값을 만족해버리면 우측은 연산조차 안되니 주의할것!
    - && : 논리곱 둘다 true(참) 일떄만 참, 둘중 하나라도 만족하지 못하면 false
    - || : 하나라도 참이면 참, 둘다 거짓일때 거짓
    - ^ : 베타 연산자, 둘의 논리 값이 서로 달라야 true, 같으면 false
    - ! : 논리부정
- 비트 연산자
    - <<, >>, >>> : bit값을 제어하는 연산자
- 연산의 방향과 우선순위
    - *, /, % 는 같은우선순위 왼쪽에서 오른쪽으로 수행
        - 산술, 쉬프트,비교,논리,조건 (연산방향 좌에서 우)
    - 단항,부호,대입 연산자는 오른쪽에서 왼쪽으로 연산
        - 증감,대입 ( 연산방향 우에서 좌)

## 제어문

제어문의 종류

- 조건문
    - if문, switch문
    - if 문 : 조건식 결과에 따라 중괄호 블록을 실행할지 여부를 결정
        - 조건식 : true 또는 false값을 산출할수 있는 연산식, 조건식이 true이면 블록을 실행, false이면 실행하지 않음
    - if else 문 : 조건식 결과에 따라 실행 블록 선택
    - if-else if-else 문 : 복수의 조건식을 두어 조건식을 만족하는 블록만 실행
    - switch문 : 변수나 연산식의 값에 따라 실행문을 선택할 때 사용
- 삼항연산자 : 세 개의 피연산자를 필요로 하는
    - 연산자 앞의 조건식 결과에 따라 콜론 앞 뒤의 피연산자 선택 → 조건 연산식
    - 조건식 ? 값또는 연산식(true) : 값 또는 연산식(false)
- 반복문 : 중괄호 블록 내용을 반복적으로 실행할 때 사용
    - for문, while문, do-while문
    - for문 : 주로 반복 횟수를 알고있을때 사용
    - while문 : 조건에 따라 반복을 계속할지 결정할 때 사용
    - do-while문 : do{실행문} while{조건식} // 조건에 따라 반복할지결정하는건 while문과 동일, 무조건 중괄호 블록을 한 번 실행한 후, 조건 검사후 반복 결정
- break문, continue문
    - break문 : for문, while문, do-while문, switch문 종료(반복 취소), 대개 if문과 같이 사용
    - break문 (반복문이 중첩된 경우) : 가장 가까운 반복문만 종료, 바깥쪽 까지 종료시키려면 반복문에 이름을 붙이고 "break 이름;" 사용
    - continue 문 : for문, while문, do-while문에서 사용
        - for문 : 증감식으로 바로이동
        - while, do- while문 : 조건식으로 바로이동
- 제어문의 중첩 : 제어문의 중괄호 내부에 다른 제어문 작성 가능 , 다양한 흐름 발생가능

## 데이터 타입 분류

- 기본타입(primitive type) : 상단참조
- 참조 타입(reference type)
    - 배열 타입
    - 열거 타입
    - 클래스
    - 인터페이스

## 데이터 타입 변환

- 타입 변환 : 데이터 타입을 다른 타입으로 변환하는 것
    - 자동(묵시적)타입 변환:Promotion // 값의 변경이 일어날 위험성이 없는것을 컴파일러가 자동으로 변경해주는것
    - 강제(명시적)타입 변환:Casting
- 자동 타입 변환 : 프로그램 실행 도중 작은 타입은 큰 타입으로 자동 타입 변환 가능
    - byte(1)<\short(2)<\int(4)<\long(8)<\float(4)<\double(8)
- 강제 타입 변환 : 큰 타입을 작은 타입 단위로 쪼개기, 끝의 한 부분만 작은 타입으로 강제적 변환

## 메모리 사용 영역

- 변수의 메모리 사용
    - 기본 타입 변수 : 실제 값을 변수 안에 저장
    - 참조 타입 변수 : 주소를 통해 객체(heap영역) 참조 // . 을통해 이동~
- JVM이 사용하는 메모리 영역 : OS에서 할당 받은 메모리 영역(Runtime ,Data, Area)을 세 영역으로 구분
    - 메소드 영역(Method Area)
        - 클래스에 대한 정보와 함께 클래스 변수(static variable)가 저장되는 영역
        - JVM은 자바 프로그램에서 특정 클래스가 사용되면 해당 클래스의 클래스 파일 (*.class)를 읽어들여, 해당 클래스에 대한 정보를 메소드 영역에 저장
    - 힙 영역(Heap Area)
        - 모든 인스턴스 변수가 저장되는 영역
        - JVM은 자바 프로그램에서 new 키워드를 사용하여 인스턴스가 생성되면, 해당 인스턴스의 정보를 힙 영역에 저장
        - 힙 영역은 메모리의 낮은 주소에서 높은 주소의 방향으로 할당
    - JVM 스택(Stack)
        - 스택(stack)영역은 자바 프로그램에서 메소드가 호출될 때 메소드의 스택 프레임이 저장되는 영역
        - JVM은 자바 프로그램에서 메소드가 호출되면, 메소드 호출과 관계되는 지역변수와 매개변수를 스택영역에 저장
        - 스택영역은 메소드의 호출과 함께 할당되며, 메소드의 호출이 완료되면 소멸
        - 스택영역에 저장되는 메소드의 호출정보를 스택 프레임(stack frame) 이라고함
        - 스택은 push 동작으로 데이터를 저장하고 pop 동작으로 데이터를 인출, 후입선출(LIFO, last in first out) 방식에 따라 동작
        - 가장 늦게 저장된 데이터가 가장 먼저 인출됨
        - 스택영역은 메모리의 높은주소에서 낮은 주소의 방향으로 할당 ↔힙영역

## 참조 변수의 == , != 연산

- 변수의 값이 같은지 다른지 비교
    - 기본 타입 : 변수의 값이 같은지 다른지 조사
    - 참조 타입 : 동일한 객체를 참조하는지 다른객체를 참조하는지 조사

## null 과 nullPointerException

- null(널)
    - 변수가 참조하는 객체가 없을 경우 초기값으로 사용 가능
    - 참조타입 변수에만 저장가능
    - null 로 초기화된 참조 변수는 스택 영역 생성
    - ==, !=연산 가능
- NullPointerException의 의미
    - 예외(Exception) : 사용자의 잘못된 조작이나 잘못된 코딩으로 인해 방생하는 프로그램 오류
    - NullPointerException : 참조 변수가 null 값을 가지고 있을 때 객체의 필드나 메소드를 사용하려고 했을 때 발생

## String 타입

- String 타입
    - 문자열을 저장하는 클래스 타입
    - 문자열 리터럴 동일하다면 String 객체 공유
    - new 연산자를 이용한 String 객체 생성
        - 힙 영역에 새로운 String 객체 생성
        - String 객체를 생성한 후 번지 리턴

## 배열 타입

- 배열이란? : 같은타입의 데이터를 연속된 공간에 저장하는 자료구조, 각데이터 저장 위치는 인덱스 부여해 접근
- 배열의 장점 : 중복된 변수 선언 줄이기 위해 사용, 반복문 이용해 요소들을 쉽게 처리
- 배열 선언 : 배열을 사용하기 위해 우선 배열 변수 선언
    - 타입[] 변수;
    - 타입 변수[];
    - 배열 변수는 참조 변수 - 배열 생성되기 전 null로 초기화 가능
    - 배열 변수가 null  값을 가진 상태에서 항목에 접근 불가
    - 데이터타입[] 변수 = {값 0, 값 1, 값 2, ...} //선언과 동시에 값 목록 대입
    - 데이터 타입 [] 변수;
    - 변수 = new 타입[] {값 0, 값 1, 값 2, 값 3, ...} // 변수 선언 후 값 목록 대입
- 배열의 길이
    - 배열변수.length;
    - 배열의 길이는 읽기 전용
    - 배열의 길이는 for문에서 조건식으로 주로 사용
- 다차원 배열
    - 2차원 배열 이상의 배열(행렬과 같은 자료구조)
- 객체를 참조하는 배열
    - 기본타입 배열은 각항목에 직접 값을 가지는 반면
    - 참조 타입 배열은 각항목에 객체의 주소를 가진다
- 향상된 for문
    - for(타입변수 : 배열){실행문}
    - 배열 및 컬렉션의 항목 요소를 순차적으로 처리
    - 인덱스 이용하지 않고 바로 항목 요소 반복
- 타입 별 항목의 기본값
    - 기본타입(정수)
        - byte[] = 0
        - char[] = '|u0000'
        - short[] = 0
        - int[] = 0
        - long[] = 0L
    - 기본타입(실수)
        - float[] = 0.0F
        - double[] = 0.0
    - 기본타입(논리)
        - boolean[] = false
    - 참조타입
        - 클래스[] =null
        - 인터페이스[] = null

## class

- 객체 지향 프로그래밍
    - OOP:Object Oreiented Programming : 부품객체를 먼저 만들고 이것들을 하나씩 조립해 완성된 프로그램을 만드는 기법
    - 객체란? : 물리적으로 존재하는것, 추상적인것 중에서 자신의 속성과 동작을 가지는 모든것 , 객체는 필드(속성) 과 메소드(동작)로 구성된 자바 객체로 모델링 가능
    - 객체의 상호 작용 : 객체들은 서로간에 기능(동작)을 이용하고 데이터를 주고 받음
    - 객체 간의 관계 : 객체 지향 프로그램에서는 객체는 다른 객체와 관계를 맺음
        - 집합 관계 : 완성품과 부품의 관계
        - 사용 관계 : 객체가 다른 객체를 사용하는 관계
        - 상속 관계 : 종류 객체와 구체적인 사물 객체 관계
- 객체지향 프로그래밍의 특징
    - 캡슐화 // 외부에서 필드에 대한 접근을 막고
        - 객체의 필드, 메소드를 하나로 묶고, 실제 구현 내용을 감추는 것
        - 외부 객체는 객체 내부 구조를 알지 못하며 객체가 노출해 제공하는 필드와 메소드만 이용 가능.
        - 필드와 메소드를 캡슐화하여 보호하는 이유는 외부의 잘못된 사용으로 인해 객체가 손상되지 않도록 하기 위함임.
        - 자바 언어는 캡슐화된 멤버를 노출시킬 것인지 숨길 것인지 결정하기 위해 접근 제한자 사용.
    - 상속
    - 다형성
- 객체와 클래스
    - 설계도 → 객체
    - 클래스 → 객체
    - 클래스에는 객체를 생성하기 위한 필드와 메소드가 정의
    - 클래스로부터 만들어진 객체를 해당 클래스의 인스턴스(instance)
    - 하나의 클래스로 부터 여러개의 인스턴스를 만들 수 있음
- 클래스의 이름
    - 자바 식별자 작성 규칙에 따라야
        1. 하나 이상의 문자로 이루어져야 한다.
        2. 첫 번째 글자는 숫자가 올 수 없다.
        3. $,  _ 외의 특수문자 사용할 수 없다
        4. 자바 키워드는 사용할 수 없다.
    - 한글 이름도 가능하나, 영어로 작성
    - 알파벳 대소문자는 서로 다른 문자로 인식
    - 첫 글자와 연결된 다른 단어의 첫 글자는 대문자로 작성하는 것이 관례
    - 이름 길이의 제한은 없지만 24자 이하로 작성하자
- 클래스 선언과 컴파일
    - 소스파일 생성 : 클래스이름.java
    - 소스파일당 하나의 클래스를 생성하는게 관례
        - 두 개 이상의 클래스도 선언가능
        - 소스 파일 이름과 동일한 클래스만 public으로 선언 가능(대소문자 도 엄격히 일치)
        - 선언한 개수만큼 바이트 코드 파일이 생성
        - public 클래스가 없을때 아무 class 이름으로 소스파일이름 가능
- new 연산자 : 객체 생성 역할 // 동적할당
    - new 클래스(); // 우리가 필요한 공간(데이터 타입)을 파악하고 그공간의 위치를 알려주는 역할
    - 생성된 객체는 힙 메모리 영역에 생성
    - new 연산자는 객체를 생성 후, 객체 생성 번지 리턴
- 클래스 변수 : new 연산자에 의해 리턴 된 객체의 번지 저장 (참조 타입 변수), 힙 영역의 객체를 사용하기 위해 사용
- 클래스의 용도
    - 라이브러리(API) 용 : 자체적으로 실행되지 않음, 다른 클래스에서 이용할 목적으로 만든 클래스
    - 실행용 : main() 메소드를 가지고 있는 클래스로 실행할 목적으로 만든 클래스
    - 1개의 애플리케이션 = (1개의 실행 클래스)+ (n 개의 라이브러리 클래스)
- 클래스의 구성 멤버
    - 필드(Field) : 객체의 데이터가 저장되는 곳
    - 생성자(Constructor) : 객체 생성시 초기화 역할 담당
    - 메소드(Method) : 객체의 동작에 해당하는 실행 블록 // 일반적으로 함수랑 같다고 생각하세요
- 필드의 내용
    - 객체의 고유 데이터 // 고정된 데이터값
    - 객체가 가져야 할 부품 객체
    - 객체의 현재 상태 데이터 // 변경될수 있는값
- 필드의 기본 초기값
    - 초기값 지정되지 않은 필드 : 객체 생성시 자동으로 기본값으로 초기화
- 필드  사용
    - 필드 값을 읽고, 변경하는 작업을 말한다
    - 필드 사용 위치
        - 객체 내부 : "필드이름" 으로 바로 접근
        - 객체 외부 : "변수.필드이름" 으로  접근
- 생성자 : new 연산자에 의해 호출되어 객체의 초기화 담당
    - 필드의 값 설정
    - 메소드 호출해 객체를 사용할 수 있도록 준비하는 역할 수행
- 기본 생성자(Default Constructor) : 모든 클래스는 생성자가 반드시 존재하며 하나 이상 가질수 있음, 생성자 선언을 생략하면 컴파일러는 다음과 같은 기본 생성자 추가
- 생성자 선언
    - 디폴트 생성자 대신 개발자가 직접 선언
    - 개발자가 선언한 생성자 존재시 컴파일러는 기본 생성자를 추가하지 않음 : new 연산자로 객체 생성시 개발자가 선언한 생성자 반드시 사용
- 필드 초기화 : 초기값 없이 선언된 필드는 객체가 생성될 떄 기본값으로 자동 설정
    - 다른값으로 필드 초기화 하는 방법
        - 필드 선언할 떄 초기값 설정
        - 생성자의 매개값으로 초기값 설정
    - 매개 변수와 필드명 같은경우 this 사용
- 생성자 다양화 해야하는 이유 : 객체 생성할 때 외부 값으로 객체를 초기화 할 필요, 외부 값이 어떤 타입으로 몇개가 제공될지 모름 -생성자도 다양화
    - 생성자 오버로딩(Overloading) : 매개변수의 타입, 개수, 순서가 다른 생성자 여러 개 선언
    - 다른 생성자 호출( this() ) : 생성자 오버로딩 되면 생성자 간의 중복된 코드 발생 , 초기화 내용이 비슷한 생성자들 에서 이러한 현상을 많이 볼수 있음
        - 초기화 내용을 한 생성자에 몰아 작성
        - 다른 생성자는 초기화 내용을 작성한 생성자를 this()로 호출

## 메소드

- 메소드란? : 객체의 동작(기능), 호출해서 실행할 수 있는 중괄호 {} 블록, 메소드 호출하면 중괄호 {} 블록에 있는 모든 코드들이 일괄 실행
- 메소드 선언 : 리턴타입 메소드이름([매개변수선언, ...]) {실행할 코드}
    - 메소드 리턴 타입 : 메소드 실행된 후 리턴하는 값의 타입, 메소드는 리턴값이 있을 수도 있고 없을 수도 있음  // 함수의 종료를 뜻하기도 한다
        - void = 반환값이 없다 는 뜻 ~ 그냥 함수가 실행만 됨
    - 메소드 이름 : 자바 식별자 규칙에 맞게 작성
    - 메소드 매개변수 선언 : 매개변수는 메소드를 실행할 떄 필요한 데이터를 외부에서 받기 위해 사용, 매개변수도 필요 없을 수 있음  // 매개변수도 타입을 지정해서 사용해야함 안그럼오류
- 리턴(return) 문
    - 메소드 실행을 중지하고 리턴값 지정하는 역할
    - 리턴 값이 있는 메소드 : 반드시 리턴문 사용해 리턴값 지정해야
    - 리턴 값이 없는 메소드 : 메소드 실행을 강제 종료 시키는 역할
- 메소드 호출 : 메소드는 클래스 내-외부의 호출에 의해 실행
    - 클래스 내부 ; 메소드 이름으로 호출
    - 클래스 외부 : 객체 생성 후, 참조 변수를 이용해 호출
- 메소드 오버로딩 : 클래스 내에 같은 이름의 메소드를 여러 개 선언하는 것
    - 하나의 메소드 이름으로 다양한 매개값 받기 위해 메소드 오버로딩
    - 오버로딩의 조건 : 매개변수의 타입, 개수, 순서가 달라야
    

## 인스턴스 멤버와 this

- 인스턴스 멤버란?
    - 객체(인스턴스) 마다 가지고 있는 필드와 메소드 : 이들을 각각 인스턴스 필드, 인스턴스 메소드라고 부름 // 객체마다 가지고있는 공간
    - 인스턴스 멤버는 객체 소속된 멤버 이기 떄문에 객체가 없이 사용불가
- this
    - 객체(인스턴스) 자신의 참조(번지)를 가지고 있는 키워드
    - 객체 내부에서 인스턴스 멤버임을 명확히 하기 위해 this. 사용
    - 매개변수와 필드명이 동일할 때 인스턴스 필드임을 명확히 하기 위해 사용
- 인스턴스 멤버는 더이상 사용하지 안으면 메모리에서 없어집니다 하지만 static은 계속 존재하기 떄문에 static 을 남발하면 안되겠습니다

## 정적 멤버와 static

- 정적(static) 멤버란?//인스턴스 생성없이 사용
    - 클래스에 고정된 필드와 메소드 - 정적 필드, 정적 메소드
    - 정적 멤버는 클래스에 소속된 멤버(하나의 공간만 차지)
        - 객체 내부에 존재하지 않고 , 메소드 영역에 존재
        - 정적 멤버는 객체를 생성하지 않고 클래스로 바로 접근해 사용
- 정적 멤버 선언
    - 필드 또는 메소드 선언할 때 static 키워드 붙임
- 정적 멤버 사용 // 기본적으로 이탤릭체!
    - 클래스 이름과 함께 도트(.) 연산자로 접근
- 인스턴스(필드) 멤버 선언 vs 정적 멤버 선언의 기준
    - 인스턴스 필드 : 객체 마다 가지고 있어야할 데이터
    - 정적 필드 : 공용적인 데이터
    - 인스턴스 메소드 : 인스턴스 필드로 작업해야 할 메소드
    - 정적 메소드 : 인스턴스 필드로 작업하지 않는 메소드
- 싱글톤(Singleton) : 하나의 애플리케이션 내에서 단 하나만 생성되는 객체
    - 싱글톤을 만드는 방법
        1. 외부에서 new 연산자로 생성자를 호출할 수 없도록 막기
            1. private 접근 제한자를 생성자 앞에 붙임
        2. 클래스 자신의 타입으로 정적 필드 선언
            1. 자신의 객체를 생성해 초기화
            2. private 접근 제한자 붙여 외부에서 필드 값 변경 불가하도록
        3. 외부에서 호출할 수 있는 정적 메소드인 getInstance() 선언
            1. 정적 필드에서 참조하고 있는 자신의 객체 리턴
    - 싱글톤 얻는 방법

# Final

- final 필드와 상수
    - 최종적인 값을 갖고 있는 필드 = 값을 변경할 수 없는 필드
    - final 필드의 딱 한번의 초기값 지정 방법
        - 필드 선언시
        - 생성자
    - 자바스크립트 const 랑 비슷한겁니다 재선언 재할당 불가능
- final 클래스와 final 메소드
    - final 키워드의 용도
        - final 필드 : 수정 불가 필드
        - final 클래스 : 부모로 사용 불가한 클래스
        - final 메소드 : 자식이 재정의할 수 없는 메소드
    - 상속할 수 없는 final 클래스
        - 자식 클래스 만들지 못하도록 final 클래스로 생성
    - 오버라이딩 불가한 final 메소드
        - 자식 클래스가 재정의 못하도록 부모 클래스의 메소드를 final로 생성

## 패키지

- 패키지란? //클래스를 구분하는 구분자가 된다
    - 클래스 선언할 때 패키지 결정
        - 클래스 선언할 때 포함될 패키지 선언
        - 클래스 파일은(~.class) 선언된 패키지와 동일한 폴더 안에서만 동작
        - 클래스 파일은(~.class) 다른 폴더 안에 넣으면 동작하지 않음
- import 문
    - 패키지 내에 같이 포함된 클래스간 클래스 이름으로 사용 가능
    - 패키지가 다른 클래스를 사용해야 할 경우
        - 패키지 명 포함된 전체 클래스 이름으로 사용
        - import 문으로 패키지를 지정하고 사용
- 접근 제한자(Access Modifier)
    - 클래스 및 클래스의 구성 멤버에 대한 접근을 제한하는 역할
        - 클래스 제한 : 다른 패키지에서 클래스를 사용하지 못하도록
        - 생성자 제한 : 클래스로부터 객체를 생성하지 못하도록
        - 필드와 메소드 제한 : 특정 필드와 메소드를 숨김 처리
    - public
        - 적용 대상 : 전부다 // 프로젝트 내에서(?)
    - protected
        - 상속과 관련된 접근 제한자
            - 같은 패키지 : default와 동일
            - 다른 패키지 : 자식 클래스만 접근 허용
    - default // 같은 패키지 내에서 사용가능
    - private // 동일한 클래스 즉 같은 인스턴스 내부에서만 사용가능

## Getter 와 Setter

- 클래스 선언할 때 필드는 일반적으로 private 접근 제한
    - 읽기 전용 필드가 있을 수 있음(Getter의 필요성)
    - 외부에서 엉뚱한 값으로 변경할 수 없도록(Setter의 필요성)
- Getter // 필드의 값을 읽어오는 녀석
    - private 필드의 값을 리턴 하는 역할 -  필요할 경우 필드 값 가공
    - getFieldName() 또는 isFieldName() 메소드
        - 필드 타입이 boolean 일 경우 isFieldName()
- Setter// 자기가 들고 있는 값을 세팅한다 그리고 검증을 한다
    - 외부에서 주어진 값을 필드 값으로 수정
        - 필요할 경우 외부의 값을 유효성 검사
    - setFieldName(타입 변수) 메소드
        - 매개 변수 타입은 필드의 타입과 동일

## 상속

- 상속(Inheritance)이란// 코드의 재사용
    - 현실 세계 : 부모가 자식에게 물려주는 행위, 부모가 자식을 선택해서 물려줌
    - 객체 지향 프로그램 : 자식(하위, 파생) 클래스가 부모(상위) 클래스의 멤버를 물려받는 것, 자식이 부모를 선택해 물려받음
        - 상속대상 : 부모의 필드와 메소드
- 상속 개념의 활용
    - 상속의 효과
        - 부모 클래스 재사용해 자식 클래스 빨리 개발 가능
        - 반복된 코드 중복 줄임
        - 유지 보수 편리성 제공
        - 객체 다형성 구현 가능 // 하나의 부모타입이 다양한 자식을 포함
        - 연관된 클래스의 공통 규약 정의
    - 상속 대상 제한
        - 부모 클래스의 private 접근 갖는 필드와 메소드 제외
        - 부모 클래스가 다른 패키지에 있을 경우 default 접근 갖는 필드와 메소드도 제외
- 클래스 상속(class extends)
    - extends 키워드 : 자식 클래스가 상속할 부모 클래스를 지정하는 키워드// extends로는 하나만 상속받을수 있음 //
    - 왜 다중상속이 안되는가?
        - 다이아몬드 문제
- 부모 생성자 호출(super(...))// this 로 다 접근이가능 하나 명시적으로 구분짓는것 !
    - 자식 객체 생성하면 부모 객체도 생성되는가?
        - 부모없는 자식 없음
        - 자식 객체 생성할 때는 부모 객체부터 생성 후 자식 객체 생성
        - 부모 생성자 호출 완료 후 자식 생성자 호출 완료
    - 명시적인 부모 생성자 호출
        - 부모 객체 생성할 떄, 부모 생성자 선택해 호출
        - super(매개값,...) : 매개값과 동일한 타입, 개수, 순서 맞는 부모 생성자 호출
        - 부모 생성자 없다면 컴파일 오류 발생
        - 반드시 자식 생성자의 첫 줄에 위치
        - 부모 클래스에 기본(매개변수 없는) 생성자가 없다면 필수 작성

## 매소드 재정의(Override)// 오버로딩과 오버라이딩 차이 구분必

- @Override 어노테이션
    - 컴파일러에게 부모 클래스의 메소드 선언부와 동일한지 검사 지시
    - 정확한 메소드 재정의 위해 붙여주면 OK
- 메소드 재정의 효과
    - 부모 메소드는 숨겨지는 효과 발생
    - 재정의된 자식 메소드 실행
- 부모 메소드 사용(super)
    - 메소드 재정의는 부모 메소드 숨기는 효과!!
        - 자식 클래스에서는 재정의된 메소드만 호출
    - 자식 클래스에서 수정되기 전 부모 메소드 호출 -super 사용
        - super는 부모 객체 참조(참고: this는 자신 객체 참조)

## 다형성과 타입변환

- 같은 타입이지만 실행 결과가 다양한 객체 대입(이용) 가능한 성질
    - 부모 타입에는 모든 자식 객체가 대입 가능
    - 자식 타입은 부모 타입으로 자동 타입 변환
    - 효과 : 객체 부품화 가능
- 자동 타입 변환(Promotion)
    - 프로그램 실행 도중에 자동 타입 변환이 일어나는 것
    - 바로 위의 부모가 아니더라도 상속 계층의 상위면 자동 타입 변환 가능
        - 변환 후에는 부모 클래스 멤버만 접근 가능
- 필드의 다형성
    - 다형성을 구현하는 기술적 방법
        - 부모타입으로 자동 변환
        - 재정의된 메소드(오버라이딩)
- 하나의 배열로 객체
- 매개변수의 다형성
    - 매개변수가 클래스 타입일 경우
        - 해당 클래스의 객체 대입이 원칙이나 자식 객체 대입하는 것도 허용
            - 자동 타입 변환
            - 매개변수의 다형성
- 강제 타입 변환
    - 부모 타입을 자식 타입으로 변환하는것
    - 조건 : 자식 타입을 부모 타입으로 자동 변환 후 , 다시 자식 타입으로 변환할 때
- 강제 타입 변환이 필요한 경우
    - 자식 타입이 부모 타입으로 자동 변환
    - 부모 타입에 선언된 필드와 메소드만 사용 가능
    - 자식 타입에 선언된 필드와 메소드를 다시 사용해야 할 경우
- 객체 타입 확인(instanceof)
    - 부모 타입이면 모두 자식 타입으로 강제 타입 변환할 수 있는 것 아님
    - ClassCastException 예외 발생 가능
    - 먼저 자식 타입인지 확인 후 강제 타입 실행해야 함

## 추상클래스(Abstaract Class)

- 추상 클래스 개념
    - 추상(abstract)
        - 실체들 간에 공통되는 특성을 추출한 것
        - 새,곤충,물고기 → 동물(추상)
        - 삼성, 현대, LG → 회사(추상)
    - 추상 클래스(abstract class)
        - 실체 클래스들의 공통되는 필드와 메소드 정의한 클래스
        - 추상 클래스는 실체 클래스의 부모 클래스 역할(단독 객체 x)
- 추상 클래스의 용도
    - 실체 클래스의 공통된 필드와 메소드의 이름 통일할 목적
        - 실체 클래스를 설계자가 여러 사람일 경우,
        - 실체 클래스마다 필드와 메소드가 제각기 다른 이름을 가질수 있음.
    - 실체 클래스를 작성할 떄 시간 절약
        - 실체 클래스는 추가적인 필드와 메소드만 선언
    - 실체 클래스 설계 규격을 만들고자 할 떄
        - 실체 클래스가 가져야 할 필드와 메소드를 추상 클래스에 미리 정의
        - 실체 클래스는 추상 클래스를 무조건 상속 받아 작성
- 추상 클래스 선언
    - 클래스 선언에 abstract 키워드 사용
        - new 연산자로 객체 생성하지 못하고 상속 통해 자식 클래스만 생성 가능
- 추상 메소드와 오버라이딩(재정의)
    - 메소드 이름 동일하지만 , 실행 내용이 실체 클래스마다 다른 메소드
    - 예: 동물은 소리를 낸다, 하지만실체 동물들의 소리는 제각기 다르다.
        - 구현방법
        - 추상 클래스에는 메소드의 선언부만 작성(추상 메소드)
        - 실체 클래스에서 메소드의 실행 내용 작성(오버라이딩(Overriding))

## 인터페이스

- 필드는 public static final 이 자동으로 붙고
- 메소드는 public abstract 가 자동으로 붙는다
- 키워드는 인터페이스 이지만 결국 클래스입니다
- 인터페이스란 ? // 추상 메소드만 가지고있는 녀석
    - 개발 코드와 객체가 서로 통신하는 접점
    - 개발코드는 인터페이스의 메소드만 알고 있으면 OK // 실제 구현되어있는 구현객체까지 알필요가 없다
    - 개발코드(메소드 호출)→인터페이스(메소드호출)→ 객체(메소드호출)
    - 개발코드  (리턴값)      ←인터페이스(리턴값)        ← 객체(리턴값)
- 인터페이스의 역할
    - 개발 코드가 객체에 종속되지 않게 → 객체 교체할 수 있도록 하는 역할
    - 개발 코드 변경 없이 리턴값 또는 실행 내용이 다양해 질 수 있음 (다형성)
- 인터페이스 선언
    - 인터페이스 이름 - 자바 식별자 작성 규칙에 따라 작성
    - 소스파일 생성 - 인터페이스 이름과 대소문자가 동일한 소스 파일 생성
    - 인터페이스 선언 - [ public ] interface 인터페이스명 { ... }
    - 인터페이스 구성멤버 // 상수와 추상메소드 이다 !
        
        ```java
        interface 인터페이스 명{
        //상수
        타입 상수명 = 값;
        //추상 메소드
        타입 메소드명(매개변수,...);
        //디폴트 메소드
        default 타입 메소드명(매개변수,...){...}
        //정적 메소드
        static 타입 메소드명(매개변수){...}
        }
        ```
        
    - 추상 메소드 선언 -인터페이스 통해 호출된 메소드는 최종적으로 객체에서 실행
        - 인터페이스의 메소드는 기본적으로 실행 블록이 없는 추상 메소드로 선언
        - public abstract를 생략하더라도 자동적으로 컴파일 과정에서 붙게 됨
    - 디폴트 메소드 선언 - 자바8에서 추가된 인터페이스의 새로운 멤버
        
        `[public] default 리턴타입 메소드명 (매개변수,...){...}`
        
        - 실행블록을 가지고 있는 메소드
        - default 키워드를 반드시 붙여야
        - 기본적으로 public 접근 제한 (생략하더라도 컴파일 과정에서 자동 붙음)
    - 정적 메소드 선언 - 자바8 에서 추가된 인터페이스의 새로운 멤버
        
        `[public] static 리턴타입 메소드명 (매개변수,...){...}`
        
- 메소드 재정의(Override)
    - 구현 객체와 구현 클래스
        - 인터페이스의 추상 메소드 대한 실체 메소드를 가진 객체 =구현 객체
        - 구현 객체를 생성하는 클래스 = 구현 클래스
    - 구현 클래스 선언
        - 자신의 객체가 인터페이스 타입으로 사용할 수 있음
        - implements 키워드로 명시
        
        `public class 구현클래스명 implements 인터페이스명{//인터페이스에 선언된 추상메소드의 실체 메소드 선언 }`
        
    - 추상 메소드의 실체 메소드를 작성하는 방법
        - 메소드의 선언부가 정확히 일치해야
        - 인터페이스의 모든 추상 메소드를 재정의하는 실체 메소드 작성해야
        - 일부만 재정의할 경우, 추상 클래스로 선언+ abstract 키워드 붙임
- protected 접근 제한자
    - 익명 구현 객체
        - 명시적인 구현 클래스 작성 생략하고 바로 구현 객체를 얻는 방법
        - 이름 없는 구현 클래스 선언과 동시에 객체 생성
        - 인터페이스의 추상 메소드들을 모두 재정의하는 실체 메소드가 있어야
        - 추가적으로 필드와 메소드 선언 가능하나 익명 객체 안에서만 사용
        - 인터페이스 변수로 접근 불가
- 인터페이스 구현
    - 다중 인터페이스 구현 클래스
    - 상속은 다중상속이 안됨 , 하지만 인터페이스는 다중구현 가능,
    - 어차피 싹다 오버라이딩? 된것과 마찬가지의 효과이기 떄문에 애매한점이 없다
    - 구현객체 여러개 지정가능
- 인터페이스 사용
    - 인터페이스에 구현 객체를 대입하는 방법
    - 추상 메소드 사용
    - 디폴트 메소드 사용// 진짜 어쩔수없을때만 사용하는것입니다 !!
        - 인터페이스만으로는 사용 불가
        - 모든 구현 객체가 가지고 있는 기본 메소드로 사용
    - 정적 메소드 사용
        - 인터페이스로 바로 호출 가능
- 타입변환과 다형성
    - 다형성
        - 하난의 타입에 여러가지 객체 대입해 다양한 실행 결과를 얻는 것
        - 다형성을 구현하는 기술
            - 상속 또는 인터페이스의 자동 타입 변환 (Promotion)
            - 오버라이딩(Overriding)
        - 다형성의 효과
            - 다양한 실행 결과를 얻을 수 있음
            - 객체를 부품화 시킬 수 있어 유지 보수 용이 (메소드의 매개변수로 사용)
    - 자동 타입 변환(promotion)
    - 필드의 다형성
    - 인터페이스 배열로 구현한 객체 관리
    - 매개변수의 다형성
        - 매개 변수의 타입이 인터페이스인 경우
        - 어떠한 구현 객체도 매개값으로 사용 가능
        - 구현 객체에 따라 메소드 실행 결과 달라짐
    - 강제 타입 변환(Casting)
        - 인터페이스 타입으로 자동 타입 변환 후, 구현 클래스 타입으로 변환
        - 필요성 : 구현 클래스 타입에 선언된 다른 멤버 사용하기 위해
    - 객체 타입 확인(instanceof 연산자)
        - 강제 타입 변환 전 구현 클래스 타입 조사
- 인터페이스 상속
    - 인터페이스간 상속 가능
        - 하위 인터페이스 구현 클래스는 아래 추상 메소드를 모두 재정의 해야함
            - 하위 인터페이스의 추상 메소드
            - 상위 인터페이스 1의 추상 메소드
            - 상위 인터페이스 2의 추상 메소드
        - 인터페이스 자동 타입 변환
            - 해당 타입의 인터페이스에 선언된 메소드만 호출 가능
- 디폴트 메소드와 인터페이스 확장
    - 디폴트 메소드와 확장 메소드 사용하기
    - 디폴트 메소드가 있는 인터페이스 상속
        - 부모인터페이스의 디폴트 메소드를 자식 인터페이스에서 활용 방법
        - 디폴트 메소드를 단순히 상속만 받음
        - 디폴트 메소드를 재정의(Override)해서 실행 내용을 변경
        - 디폴트 메소드를 추상 메소드로 재선언

## 람다식

- 자바 8부터 함수적 프로그래밍 위해 람다식 지원
    - 추상 메소드 하나를 가지고 있는 인터페이스를 쉽게 사용하기위해 나온것
    - 함수형 인터페이스 라고도 한다
    - 람다식(Lambda Expressions)을 언어 차원에서 제공
    - 자바는 람다식을 함수적 인터페이스의 익명 구현객체로 취급
    - 자바에서 람다식을 수용한 이유
        - 코드가 매우 간결해진다.
        - 컬렉션 요소(대용량 데이터)를 필터링 또는 매핑해 쉽게 집계
    - 자바는 람다식을 함수적 인터페이스의 익명 구현 객체로 취급
        - 어떤 인터페이스를 구현할지는 대입되는 인터페이스에 달려있음
- 람다식 기본 문법
    - 함수적 스타일의 람다식 작성법
        - `(타입 매개변수, ...) ->{실행문}`
        - 매개 타입은 런타임시에 대입값 따라 자동 인식 → 생략가능
        - 하나의 매개변수만 있을 경우에는 괄호() 생략 가능
        - 하나의 실행문만 있다면 중괄호 {} 생략가능
        - 매개변수 없다면 괄호 () 생략불가
        - 리턴값이 있는 경우, return 문 사용
        - 중괄호{} 에 return 문만 있을 경우, 중괄호 생략 가능
- 타켓 타입과 함수적 인터페이스
    - 타겟 타입(target type)
        - 람다식이 대입되는 인터페이스
        - 익명 구현 객체를 만들 때 사용할 인터페이스
        - `인터페이스 변수 = 람다식;`
    - 함수적 인터페이스(functional interface)
        - 하나의 추상 메소드만 선언된 인터페이스가 타겟 타입
        - @FunctionalInterface 어노테이션
            - 하나의 추상메소드만을 가지는지 컴파일러가 체크
            - 두 개 이상의 추상 메소드가 선언되어 있으면 컴파일 오류 발생
    - 매개변수와 리턴값이 없는 람다식
        - Method()가 매개 변수를 가지지 않는 경우
        - `MyInterface fi = () -> { ... }`
    - 매개변수가 있는 람다식
        - `MyInterface fi = (x) -> { ... }` or `x->{ ... }`
    - 리턴값이 있는 람다식

## Object class

- 자바의 최상위 부모 클래스
- 다른 클래스를 상속하지 않으면 java.lang.Obgect 클래스 상속 암시
- Object의 메소드는 모든 클래스에서 사용 가능
- 객체 문자 정보(toString())
    - 객체를 문자열로 표현한 값
    - Object 클래스의 toString() 메소드는 객체의 문자 정보 리턴
    - 일반적으로 의미 있는 문자 정보가 나오도록 재정의
    - date 클래스 - 현재 시스템의 날짜와 시간정보 리턴
    - String 클래스 - 저장하고 있는 문자열 리턴
    - System.out,println(Object) 메소드 : Object의 toString() 의 리턴값 출력
- 객체 비교 (equals() 메소드)
    - `public boolean equals(Object abj){...}`
    - 기본적으로 == 연산자와 동일한 결과 리턴(번지 비교)
    - 논리적 동등 위해 오버라이딩 필요
        - 논리적 동등 : 같은 객체이건 다른 객체이건 상관없이 객체 저장 데이터 동일
    - Object의 equals() 메소드 : 재정의 하여 논리적 동등 비교할 때 이용
- 객체 해시코드(hashCode())
    - 객체 해시코드란?
        - 객체를 식별할 하나의 정수값
        - 객체의 메모리 번지를 이용해 해시코드 만들어 리턴
        - 개별 객체는해시코드가 모두 다름
    - 논리적 동등 비교 시 hashCode() 오버라이딩의 필요성
        - 컬렉션 프레임워크의 HashSet, HashMap, Hashtable과 같은 클래스는 두객체가 동등한 객체인지 판단할 때 아래와 같은 과정을 거침
        - hashcode() 리턴값 —> 같음 —> equals() 리턴값 —>true—> 동등객체
            
                  ㄴ —> 다름—> 다른객체 <—false<—-l
            
- 객체 복제(clone())
    - 원본 객체의 필드값과 동일한 값을 가지는 새로운 객체 생성하는 것
    - 복제 종류
        - 얕은 복제(thin clone): 필드 값만 복제(참조 타입 필드는 번지 공유)
        - 깊은 복제(deep clone): 참조하고 있는 객체도 복제
    - Object의 clone() 메소드
        - 동일한 필드 값 을 가진 얕은 복제된 객체 리턴
        - java.lang.Cloneable 인터페이스 구현한 객체만 복제 가능
    - 깊은 복제 - clone() 메소드 재정의 하고 참조 객체도 복제해야
- 객체 소멸자(finalize())
    - GC는 객체를 소멸하기 직전 객체 소멸자(finalize()) 실행
    - Object의 finalize()는 기본적으로 실행내용이 없음
    - 객체가 소멸되기 전에 실행할 코드가 있다면? : Object의 finalize()재정의
    - 될 수 있으면 소멸자는사용하지 말 것
    - GC는 메모리의 모든 쓰레기 객체를 소멸하지 않음
    - GC의 구동시점이 일정하지 않음

[Object의 유틸리티 클래스](https://www.notion.so/0d5c8d3f060f4a6e9a5cc1977aff027c)

## String class

[String 메소드](https://www.notion.so/ea3246afab094c3a93fa99237e3b5da3)

- 문자 추출(charAt())
    - 매개값으로 주어진 인덱스의 문자 리턴
- 문자열 비교(equals())
- 문자열 찾기(indexOf())
    - 매개값으로 주어진 문자열이 시작되는 인덱스 리턴
    - 주어진 문자열이 포함되어 있지 않으면 -1 리턴
    - 특정 문자열이 포함되어 있는지 여부에 따라 실행 코드 달리할 때 사용
- 문자열 길이(length()) //공백도 문자에 포함

- 문자열 대치(replace())
    - 첫 번째 매개값인 문자열 찾음
    - 두 번째 매개값인 문자열로 대치
    - 새로운 문자열 리턴
- 문자열 잘라내기(substring())
    - `substring(int beginIndex, int endIndex)` : 주어진 시작과 끝 인덱스 사이의 문자열 추출
    - `substring(int beginIndex)` : 주어진 인덱스 이후부터 끝까지 문자열 추출
- 알파벳 소,대 문자 변경(toLowerCase(),toUpperCase())
- 문자열 앞뒤 공백 잘라내기(trim())
- 문자열 변환(valueOf())
- 생성자- byte[]배열을 문자열로 변환하는 생성자
    - 키보드로 부터 읽은 바이트 배열을 문자열로 변환
- StringTokenizer 클래스
    - 문자열 분리 방법
        - String 의 split() 메소드 이용
        - java.util.StringTokenizer 클래스 이용
    - String의 split()
        - 정규 표현식을 구분자로 해서 부분 문자열 분리
        - 배열에 저장하고 리턴
    - int countTokens() : 꺼내지 않고 남아있는 토큰의 수
    - boolean hasMoreTokens() : 남아 있는 토큰이 있는지 여부
    - String nextToken() : 토큰을 하나씩 꺼내옴
- StringBuffer, StringBuilder 클래스
    - 문자열 결합 연산자+
        - String 은 내부의 문자열 수정 불가 → 대치된 새로운 문자열 리턴
        - 이방법으로 하면 메모리가 낭비된다 그래서 StringBuffer 나 StringBuilder를 이용한다
    - StringBuffer, StringBuilder
        - 버퍼(buffer:데이터를 임시로 저장하는 메모리)에 문자열 저장
        - 버퍼 내부에서 추가,수정,삭제 작업 가능
        - 멀티 스레드 환경 : StringBuffer 사용 // 동기화 환경에서 안정적으로 사용 가능
        - 단일 스레드 환경: StringBuilder 사용

## Wrapper class

- 포장(Wrapper) 객체란?
    - 기본타입 (byte, char, short, int, long, float, double, boolean) 값을 내부에 두고 포장하는 객체
    - 기본타입의 값은 외부에서 변경 불가
    
    ![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/13453019-1a85-4df4-a0f6-c9d434b24411/Untitled.png)
    
- 박싱(Boxing)과 언박싱(Unboxing)
- 박싱(Boxing) : 기본타입의 값을 포장 객체로 만드는 과정
- 언박싱(unboxing) : 포장 객체에서 기본 타입의 값을 얻어내는 과정

## Math class

수학계산에 사용할수 있는 정적 메소드 제공

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/73059cd3-3d3c-4c0f-82c1-0ba21ed0839d/Untitled.png)

## Random class

- boolean, int, long, float, double 난수 입수 가능
- 난수를 만드는 알고리즘에 사용되는 종자값(seed) 설정 가능, 종자값이 같으면 같은 난수
- Random 클래스로 부터 Random 객체 생성하는 방법
    - `Random()` : 호출시 마다 다른 종자값(현재 시간 이용) 이 자동 설정된다.
    - `Random(long seed)`: 매개값으로 주어진 종자값이 설정된다
- Random 클래스가 제공하는 메소드
    - `nextBoolean()` : boolean 타입의 난수를 리턴
    - `nextDouble()` : double 타입의 난수를 리턴(0.0≤ ~ < 1.0)
    - `nextInt()` : int 타입의 난수를 리턴 (-2^32≤ ~ ≤ 2^32-1);
    - `nextInt(int n)` : int 타입의 난수를 리턴 (0≤ ~ <\n)
    

## Arrays class

배열 조작 기능을 가지고 있는 클래스 - 배열복사, 항목 정렬, 항목 검색 등을 제공하는 정적메소드

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/de666c0f-ebb7-4fcb-b3d0-b4422d9c7aeb/Untitled.png)

- 배열 복사
    - `Arrats.copyOf(원본배열,복사할 길이)` : 0~(복사할 길이-1) 까지 항목 복사 (복사할 길이는 워본배열의 길이보다 커도됨.)
    - `copyOfRange(원본 배열, 시작 인덱스, 끝 인덱스)` : 시작인덱스 ~(끝 인덱스 -1) 까지 항목 복사
    - `System.arraycopy(월본 배열, 원본시작인덱스, 타겟배열, 타겟시작인덱스, 복사개수)`
- 배열 항목 비교
    - `Arrays.equals(배열,배열)` : 1차 항목의 값만 비교
    - `Arrays.deepEquals(배열,배열)` : 중첩된 배열의 항목까지 비교
- 배열 항목 정렬
    - `Arrays.sort(배열)` : 항목 오름차 순으로 정렬, 기본 타입이거나 String 배열 자동 정렬
        - 사용자 정의 클래스 배열은 Comparable 인터페이스를 구현해야만 정렬
- 배열 항목 검색
    - 특정 값 위치한 인덱스 얻는 것
    - `Arrays.sort(배열)`로 먼저 정렬
    - `Arrays.binarySearch(배열,찾는 값)` 메소드로 항목을 찾아야 정확한 값이 나옴

## Format 클래스

- 형식(Format)클래스
    - 숫자와 날짜를 원하는 형식의 문자열로 변환
    - 종류
        - 숫자형식 :DecimalFormat
        - 날짜형식:SimpleDateFormat
        - 매개변수화 된 문자열 형식:MessageFormat
- 숫자 형식 클래스(DecimalFormat)
    - 적용할 패턴 선택해 생성자 매개값으로 지정 후 개게 생성
- 날짜 형식 클래스(SimpleDateFormat)

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/cd0fd7d6-ac42-4bf1-b0ab-a782c4447112/Untitled.png)

- 매개변수화 된 문자열 형식 클래스(MessageFormat)

## 예외처리

- 예외의 종류
    - 에러(Error)
        - 하드웨어의 잘못된 동작 또는 고장으로 인한 오류
        - 에러가 발생되면 프로그램 종료
        - 정상 실행 상태로 돌아갈 수 없음
    - 예외(Exception)
        - 사용자의 잘못된 조작 또는 개발자의 잘못된 코딩으로 인한 오류
        - 예외가 발생되면 프로그램 종료
        - 예외 처리 추가하면 정상 실행 상태로 돌아갈 수 있음
    - 일반(컴파일 체크) 예외 (Exception)
        - 예외 처리 코드 없으면 컴파일 오류 발생
    - 실행 예외(RuntimeException)
        - 예외 처리 코드를 생략하더라도 컴파일이 되는 예외
        - 경험 따라 예외 처리 코드 작성 필요
- 예외 클래스
    - java.lang.Exception // 최상위
    - java.lang.ClassNotFoundException, java.lang.InterruptedException .. 등등 일반 컴파일러 케츠 예외
    - java.lang.RuntimeException
        - java.lang.NullPointerException // 실행 예외들
        - java.lang.NumberFormatException
- 실행 예외(RuntimeException)
    - ClassCastException : 타입 변환이 되지 않을 경우 발생
- 예외 처리 코드(try-catch-finally)
    - 예외 발생시 프로그램 종료 막고 정상 실행 유지할 수 있도록 처리
    - 일반 예외 : 반드시 작성해야 컴파일 가능
    - 실행 예외: 컴파일러가 체크해주지 않으며 개발자 경험 의해 작성
    - try - catch -finally 블록 이용해 예외 처리 코드 작성
    - try 문은 검증하는 과정을 거치기떄문에 일반실행문보다 속도가 현저히 느리다
    - 그러므로 꼭 필요한곳에만 사용할것 !!
    - 다중 catch : 예외별로 예외 처리 코드 다르게 구현
    - catch 순서 - 상위 클래스가 밑에 위치해야 함
    - 멀티(multi) catch
        - 자바 7부터는 하나의  chach 블록에서 여러 개의 예외 처리 가능
        - 동일하게 처리하고 싶은 예외를 |로 연결
    - 코드를 작성하는데 예외처리를 강제하는 경우가 있음 cloned 처럼 그게 바로 컴파일 Exception 이다 !
- 예외 떠 넘기기
    - throws // 예외를 직접 처리하는게아니고 오류를 다른쪽에서 처리하도록 떠넘김
        - 메소드 선언부 끝에 작성
        - 메소드에서 처리하지 않은 예외를 호출한 곳으로 떠 넘기는 역할
- 자동 리소스 닫기
    - try-with-resources
        - 예외 발생 여부와 상관 없음
        - 사용했던 리소스 객체의 close() 메소드 호출해 리소스 닫음
        - 리소스 객체
            - 각종 입출력 스트림,서버소켓,소켓,각종채널,
            - java.lang.AutoCloseable 인터페이스 구현하고 있어야함
- 사용자 정의 예외와 예외 발생
    - 사용자 정의 예외 클래스 선언
        - 자바 표준API에서 제공하지 않는 예외
        - 애플리케이션 서비스와 관련된 예외 // 잔고부족, 계좌이체 실패,회원가입실패 등등
        - 사용자 정의 예외 클래스 선언 방법
        - Exception 객체를 상속받아서 명시적으로 이런오류를 처리해라고 알려줄수있음
- 예외 정보 얻기
    - getMessage()
        - 예외 발생시킬 떄 생성자 매개값으로 사용한 메시지 리턴
        - 원인 세분화 하기 위해 예외 코드 포함(예: 데이터 베이스 예외 코드)
        - catch() 절에서 활용
    - printStackTrace()
        - 예외 발생 코드 추적한 내용을 모두 콘솔에 출력
        - 프로그램 테스트 하면서 오류 찾을 떄 유용하게 활용
        

## 제네릭

- 제네릭(Generic) 타입이란? // 강력한 타입제안자다
    - 컴파일 단계에서 '잘못된 타입 사용될 수 있는 문제' 제거 가능
    - 자바 5부터 새로 추가
    - 컬렉션, 람다식(함수적 인터페이스), 스트림, NIO에서 널리 사용
    - 제네릭을 모르면 API 도큐먼트 해석 어려우므로 학습 필요]
    - 타입을 파라미터로 가지는 클래스와 인터페이스
    - 선언 시 클래스 또는 인터페이스 이름 뒤에 "<>"부호 붙임
    - "<>"사이에는 타입 파라미터 위치
    - 타입 파라미터
        - 일반적으로 대문자 알파벳 한 문자로 표현
        - 개발 코드에서는 타입 파라미터 자리에 구체적인 타입을 지정해야
- 제네릭을 사용하는 코드의 이점
    - 컴파일시 강한 타입 체크 가능
    - 실행시 타입 에러가 나는 것 방지
    - 컴파일 시에 미리 타입을 강하게 체크해서 에러 사전 방지
    - 타입변환 제거 가능
- 제네릭 타입 사용 여부에 따른 비교
    - 제네릭 타입을 사용하지 않은 경우
        - Object 타입 사용 → 빈번한 타입 변환 발생 → 프로그램 성능 저하
    - 제네릭 타입을 사용한 경우
        - 클래스 선언할때 타입 파라미터 사용
        - 컴파일 시 타입 파라미터가 구체적인 클래스로 변경
- 멀티 타입 파라미터
    - 제네릭 타입은 두 개 이상의 타입 파라미터 사용 가능
        - 각 타입 파라미터는 콤마로 구분
        - Ex) class<K, V, ...> { ... }
        - interface<K, V, ...> { ... }
        - 자바 7 부터는 다이아몬드 연산자 사용해 간단히 작성과 사용 가능
- 제네릭 메소드
    - 매개 변수 타입과 리턴 타입으로 타입 파라미터를 갖는 메소드
    - 제네릭 메소드 선언 방법
        - 리턴 타입 앞에"<>"기호를 추가하고 타입 파라미터 기술
        - 타입 파라미터를 리턴 타입과 매개변수에 사용
    - 제네릭 메소드 호출하는 두 가지 방법
- 제한된 타입 파라미터
    - 타입 파라미터에 지정되는 구체적인 타입 제한할 필요
        - 상속 및 구현관계 이용해 타입 제한
            - 상위 타입은 클래스 뿐만 아니라 인터페이스도 가능
        - 타입 파라미터를 대체할 구체적인 타입
            - 상위 타입이거나 하위 또는 구현 클래스만 지정 가능
- 타입변환과 다형성
    - 제네릭 타입을 부모 클래스로 사용할 경우
        - 타입 파라미터는 자식 클래스에도 기술해야!
        - 추가적인 타입 파라미터 가질 수 있음
    - 제네릭 인터페이스를 구현할 경우
        - 제네릭 인터페이스를 구현한 클래스도 제네릭 타입
        - 개념 확실히 이해할것

## 컬렉션 프레임 워크

- 컬렉션 프레임 워크(Collection Framework)
    - 컬렉션
        - 사전적 의미로 요소(객체)를 수집해 저장하는 것
        - 여러 객체(데이터)를 모아 놓은 것을 의미
    - 프래임웍(frame work)
        - 표준화, 정형화된 체계적인 프로그래밍 방식
        - 프로그래밍 생산성이 올라가고
        - 유지보수가 쉽다
        - 라이브러리는 필요한 기능만 제공해주는 반면에
        - 라이브러리 + 프로그래밍 방식
    - 컬렉션 프레임 웍(collections framework)
        - 컬렉션(다수의 객체)를 다루기 위한 표준화된 프로그래밍 방식
        - 컬렉션을 쉽고 편리하게 다룰수 있는 다양한 클래스를 제공
        - 저장,삭제,검색,정렬 등
        - java.util 패키지에 포함 . JDK1.2부터 제공
    - 컬렉션 클래스(collection class)
        - 다수의 데이터를 저장할 수 있는 클래스(예, Vector,ArratList,HashSet)
    - 배열의 문제점
        - 저장할 수 있는 객체 수가 배열을 생성할 때 결정 ⇒ 불특정 다수의 객체를 저장하기에는 문제
        - 객체 삭제 했을 때 해당 인덱스가 비게 됨 ⇒낱알 빠진 옥수수 같은 배열 ⇒객체 저장하려면 어디가 비어있는지 확인해야함
    - 객체들을 효율적으로 추가, 삭제, 검색할 수 있도록 제공되는 컬렉션 라이브러리
    - java.util 패키지에 포함
    - 인터페이스를 통해서 정형화된 방법으로 다양한 컬렉션 클래스 이용
- 컬렉션 프레임워크의 주요(핵심) 인터페이스

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/2f637fd3-b489-4cc8-b565-2643ae59fb7e/Untitled.png)

- 각데이터의 특징에 맞게 잘 선택해서 사용해야한다
- List 컬렉션의 특징 및 주요 메소드
    - 특징
        - 순서가 있고 인덱스로 관리
        - 중복을 허용해서 객체로 저장 가능
        - 예) 대기자 명단
    - 구현 클래스
        - ArrayList
        - Vector
        - LinkedList
    - 주요 메소드(어떤 데이터 타입을 사용할지 제네릭으로 지정해야한다!!)
    
    ![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/7d11354b-75b5-4081-848a-9d4858e0f61b/Untitled.png)
    
- List 컬렉션
    - ArrayList
        - 저장 용량(capacity)
            - 초기 용량 : 10 (따로 지정 가능)
            - 저장용량을 초과한 객체들이 들어오면 자동적으로 늘어남. 고정도 가능
        - 객체 제거
            - 바로 뒤 인덱스부터 마지막 인덱스까지 모두 앞으로 1씩 당겨짐
            1. 삭제할 데이터 아래의 데이터를 한 칸씩 위로 복사해서 삭제할 데이터를 덮어 쓴다. //부담이 많이가는 작업 되도록 이작업이 일어나지 않도록하자
            2. 데이터가 모두 한 칸씩 이동 했으므로 마지막 데이터는 null로 변경한다
            3. 데이터가 삭제되어 데이터의 개수가 줄었으므로 size의 값을 감소시킨다
            4. 마지막 데이터를 삭제하는 경우 1. 의 과정은 필요없다
    - Vector
        - 특징
            - Vector는 스레드 동기화(synchronization)
                - 복수의 스레드가 동시에 Vector에 접근해 객체를 추가, 삭제하더라도 스레드에 안전(thread safe) //스레드를 알기전까진 알수없다 기본적으로 어레이랑 동일하다
    - LinkedList(이중연결리스트)
        - 특징
            - 인접 참조를 링크해서 체인처럼 관리
            - 특정 인덱스에서 객체를 제거하거나 추가하게 되면 바로 앞 뒤 링크만 변경
            - 빈번한 객체 삭제와 삽입이 일어나는 곳에서 ArrayList 보다 좋은 성능
- Set 컬렉션
    - 특징
        - 수학의 집합에 비유
        - 저장순서가 유지되지 않음
        - 객체를 중복 저장 불가, 데이터의 중복을 허용하지않음
        - 하나의 null만 저장 가능
        - 예) 집합 , 네발동물 집합
    - 구현 클래스
        - HashSet
        - LinkedHashSet
        - TreeSet
    - 주요 메소드
    
    ![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/fb37d424-480a-46b8-a9f4-da5374653107/Untitled.png)
    
    - 전체 객체 대상으로 한 번씩 반복해 가져오는 반복자(Iterator) 제공
        - 인덱스로 객체를 검색해서 가져오는 메소드 없음
    - HashSet
        - 특징
            - 동일 객체 및 동등 객체는 중복 저장하지 않음
            - 동등 객체 판단 방법 : hashCode()리턴값 , equals()리턴값 일치 // 해시코드 값으로만은 중복의 가능성이 있기떄문에
- Map 컬렉션
    - 특징
        - 키(key)와 값(value)으로 구성된 Map.Entry 객체를 저장하는 구조
        - 키와 값은 모두 객체
        - 키는 중복될 수 없지만 값은 중복 저장 가능
            - 즉 같은 키는 존재할수없고
            - 같은 값은 존재할수 있다
        - 예) 우편번호, 지역번호, 아이디와 패스워드
    - 구현 클래스
        - HashMap, Hashtable, LinkedHashMap, Properties, TreeMap
    - 주요 메소드
    
    ![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/83ac692f-3d69-4dce-8ab3-4fe455d96249/Untitled.png)
    
    - HashMap
        - 특징
            - 키 객체는 hashCode()와 equals()를 재정의해 동등 객체가 될 조건을 정해야함
            - 키 타입은 String 많이 사용
            - String은 문자열이 같을 경우 동등 객체가 될 수 있도록 hashCode()와 equals()메소드가 재정의 되어 있기 때문
    - Hashtable
        - 특징
            - 키 객체 만든느 버은 HashMap과 동일
            - Hashtable은 스레드 동기화(synchronization)가 된 상태
            - 복수의 스레드가 동시에 Hashtable에 접근해서 객체를 추가, 삭제 하더라도 스레드에 안전(thread safe)
    - Properties
        - 특징
            - 키와 값을 String 타입으로 제한한 Map 컬렉션
            - Properties는 프로퍼티(~.properties) 파일을 읽어 들일 떄 주로 사용
        - 프로퍼티(~.properties) 파일 // 주로 랭기지 팩같은데 사용되는걸 볼수있다
            - 옵션 정보,데이터베이스 연결 정보, 국제화(다국어) 정보를 기록//텍스트파일로활용
            - 애플리케이션에서 주로 변경이 잦은 문자열을 저장// 유지보수를 편리하게 만들어줌
            - 키와 값이 = 기호로 연결되어 있는 텍스트 파일
                - ISO 8859-1 문자셋으로 저장
                - 한글은 유니코드로 변환되어 저장
- 검색 기능을 강화시킨 컬렉션(계층구조 활용)
    - TreeSet, TreeMap =>이진 트리 (binary tree) 사용하기 떄문에 검색속도 향상
    - 이진 트리 구조
        - 부모 노드와 자식 노드로 구성
            - 왼쪽 자식 노드 : 부모보다 적은값
            - 오른쪽 자식 노드 : 부모보다 큰 값
        - 정렬 쉬움
            - 올림 차순 : 왼쪽노드 → 부모노드 → 오른쪽노드
            - 내림 차순 : 오른쪽노드→부모노드→왼쪽노드
    - TreeSet
        - 특징
            - 이진 트리 (binary tree)를 기반으로 한 Set 컬렉션
            - 왼쪽과 오른쪽 자식 노드를 참조 하기 위한 두 개의 변수로 구성
        - 주요 메소드
            - 특정 객체를 찾는 메소드: first(), last(), lower(), higher(), ...
            - 정렬 메소드 : descendingIterator(), descendingSet()
            - 범위 검색 메소드 : headSet(), tailSet,subSet()
    - TreeMap
        - 특징
            - 이진 트리(binary tree) 를 기반으로 한 Map 컬렉션
            - 키와 값이 저장된 Map.Entry를 저장
            - 왼쪽과 오른쪽 자식 노드를 참조하기 위한 두개의 변수로 구성
        - 주요 메소드
            - 단일 노드 객체를 찾는 메소드 : firstEntry(), lastEntry(), lowerEntry(), higherEntry(), ...
            - 정렬 메소드 : descendingKeySet(), descendingMap()
            - 범위 검색 메소드 : headMap(), tailMap, subMap()
- LIFO 와 FIFO 컬랙션
    - Stack 클래스
        - 특징
            - 후입선출(LIFO : Last in first Out) 구조
            - 응용 예 : JVM 스택 메모리
        - 주요메소드
        
        ![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/0a9c99a2-2572-4eb2-9f8d-fa3c954f4694/Untitled.png)
        
    - Queue 인터페이스
        - 특징
            - 선입선출(FIFO : First In First Out)
            - 응용 예 : 작업 큐, 메시지 큐, ...
            - 구현 클랙스 : LinkedList
        - 주요메소드
        
        ![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/e5563e88-8ee6-4b4a-bc77-a4896310d502/Untitled.png)
        
- 검색 기능을 강화시킨 컬렉션
    - Comparable 과 Comparator // 정렬 기준을 잡는 녀석들
        - TreeSet과 TreeMap 의 자동 정렬
        - TreeSet 의 객체와 TreeMap의 키는 저장과 동시에 자동 오름차순 정렬
        - 숫자(Integer, Double) 타입일 경우에는 값으로 정렬
        - 문자열(String) 타입일 경우에는 유니코드로 정렬
        - TreeSet 과 TreeMap은 정렬 위해 java.lang.comparable을 구현 객체를 요구
            - Integer, Double, String 은 모두 Comparable 인터페이스 구현
            - Comparable을 구현하고 있지 않을 경우에는 저장하는 순간 ClassCastException 발생
            

## IO기반 입출력

- java.io 패키지
    - 자바의 기본적인 데이터 입출력(IO:input/Output) API제공

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/6129270a-4bca-412a-b9bc-baa82821afe7/Untitled.png)

- 입력 스트림과 출력 스트림
    - 입력 스트림과 출력 스트림의 개념
        - 출발지 ⇒ 프로그램 ⇒ 도착지
        - 입력스트림             출력스트림
        - 프로그램 간의 교환도 가능함  : 보낼때는 출력 스트림 받아들일떄는 입력 스트림
    - 바이트 기반 스트림과 문자 기반 스트림
        - 바이트 기반 스트림 : 그림, 멀티미디어, 문자 등 모든 종류의 데이터를 받고 보내는 것 가능
        - 문자 기반 스트림 : 문자만 받고 보낼 수 있도록 특화
    - InputStream
        - 바이트 기반 입력 스트림의 최상위 클래스로 추상 클래스
        - inputStream 클래스의 주요 메소드
        
        ![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/4cdb871d-7a05-4e4a-8548-696efd947f72/Untitled.png)
        
    - OutputStream
        - 바이트 기반 출력 스트림의 최상위 클래스로 추상 클래스
        - outputStream 클래스의 주요 메소드
        
        ![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/e44b2cd1-d2a6-493e-b461-d1b7aeccefe6/Untitled.png)
        
    - Reader
        - 문자 기반 입력 스트림의 최상위 클래스로 추상 클래스
        - Reader 클래스의 주요 메소드
        
        ![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/d64d0fa7-4e7b-4518-a3a6-577221fe2a48/Untitled.png)
        
    - Writer
        - 문자 기반 출력 스트림의 최상위 클래스로 추상 클래스
        - Writer 클래스의 주요 메소드
        
        ![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/ff9c9b05-5807-4849-a2b2-7198b6c5d340/Untitled.png)
        
- 콘솔 입출력
    - 콘솔(Console)
        - 시스템을 사용하기 위해 키보드로 입력을 받고 화면으로 출력하는 소프트웨어
        - Unix, Linux : 터미널
        - Windows 운영체제 : 명령 프롬프트
        - 이클립스 : Console 뷰
    - System.in 필드
        - inputStream 타입의 입력 스트림 - InputStream 변수 대입
        - 읽은 byte 는 키보드의 아스키 코드(ascii code)
        - 아스키 코드로부터 문자 변환
        - 키보드로부터 입력된 한글 읽기 예쩨
            - read()메소드는 1바이트 씩만 읽음 → 오류 발생
            - 전체 내용을 바이트 배열로 받아 String 객체 생성 후 읽기
    - System.out 필드
        - printStream 타입의 출력 스트림
        - OutputStream 으로 타입 변환 가능
        - 아스키 코드를 출력하면 콘솔에는 문자가 출력
        - 문자열을 출력하려면 바이트 배열을 얻어야
    - Console 클래스
        - 자바6부터 콘솔에서 입력된 문자열을 쉽게 읽을 수 있도록 제공
        - 이클립스에서 System.console()은 null리턴 , 명령 프롬프트에서 반드시 실행
        - Console클래스의 읽기 메소드
        
        ![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/437bbee4-c878-4619-a607-08d1c7afdab7/Untitled.png)
        
    - Scanner 클래스
        - Console 클래스의 단점 : 문자열은 읽을 수 있지만 기본 타입(정수, 실수) 값을 바로 읽을수 없음.
        - java.util.Scanner : 콘솔로 부터 기본 타입의 값을 바로 읽을 수 있음
        - 제공하는 메소드
        
        ![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/85a4a545-15a8-4b2b-9fdd-08c1d84c36a7/Untitled.png)
        

- 파일 입출력
    - File 클래스
        - 파일 시스템의 파일을 표현하는 클래스
        - 파일 크기, 파일 속성, 파일이름 등의 정보 제공
        - 파일 생성 및 삭제 기능 제공
        - 디렉토리 생성, 디렉토리에 존재하는 파일 리스트 얻어 내는 기능 제공
    - 파일 객체 생성
    - 파일 또는 디렉토리 존재 유무 확인 메소드
    - 파일 및 디렉토리 생성 및 삭제 메소드
    
    ![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/ac634817-f36a-4af4-9eae-bb9f06ffbf55/Untitled.png)
    
    - 파일 및 디렉토리의 정보를 리턴하는 메소드
    
    ![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/ecd35e37-b7fb-4c02-902a-76e322af810b/Untitled.png)
    
    - FileInputStream
        - 파일로부터 바이트 단위로 읽어 들일 때 사용
            - 그림, 오디오, 비디오, 텍스트 파일 등 모든 종류의 파일을 읽을수 있음
        - 객체 생성 방법
            - FileInputStream 객체가 생성될 때 파일과 직접 연결
            - 만약 파일이 존재하지 않으면 FileNotFoundException 발생 try-catch문으로 예외 처리
        - InputStream 하위 클래스 - 사용 방법이 InputStream 과 동일
    - FileOutputStream
        - 파일에 바이트 단위로 데이터를 저장할 때 사용
            - 그림,그림, 오디오, 비디오, 텍스트 파일 등 모든 종류의 데이터를 파일로 저장
            - 객체 생성 밥법 : 파일이 이미 존재할 경우, 데이터를 출력하게 되면 파일을 덮어쓴느 단점, 기존 파일 내용 끝에데이터를 추가할 경우
            - OutputStream 하위 클래스 - 사용 방법이 OutputStream과 동일
    - FileReader
        - 텍스트 파일로 부터 데이터를 읽어 들일때 사용
            - 문자 단위로 읽음, 텍스트 제외하곤 못읽음
            - 객체 생성 방법
                - FileReader 객체가 생성될 때 파일과 직접 연결
                - 만약 파일이 존재하지 않으면 FileNotFoundException 발생 try-catch 문으로 예외 처리
        - Reader 하위 클래스 - 사용 방법 reader와 동일
    - FileWriter
        - 텍스트 파일에 문자 데이터를 저장할 때 사용, 문자 제외하고 저장불가
        - 객체 생성 방법
            - 파일이 이미 존재할 경우, 데이터를 출력하게 되면 파일을 덮어 쓰게됨. 파일 존재 여부 따라 분기
            - 기존 파일 내용 끝에 데이터를 추가할 경우
        - Writer하위 클래스 - 사용 방법이 Writer와 동일
- 보조 스트림
    - 보조스트림
        - 다른 스트림과 연결되어 여러가지 편리한 기능을 제공해주는 스트림
            - 문자 변환, 입출력 성능 향상, 기본 데이터 타입 입출력, 객체 입출력 등의 기능을 제공
        - 보조 스트림 생성
        - 보조 스트림 체인 - 다른 보조 스트림과 연결되어 역할 수행
    - 문자 변환 보조 스트림
        - 소스 스트림이 바이트 기반 스트림이지만 데이터가 문자일 경우 사용
            - Reader와 Writer는 문자 단위로 입출력- 바이트 기반 스트림보다 편리 문자셋의 종류를 지정할 수 있기 떄문에 다양한 문자 입출력 가능
            - InputStreamReader
            - OutputStreamWriter
    - 성능 향상 보조 스트림
        - 입출력 성능에 영향을 미치는 입출력 소스
            - 하드 디스크
            - 느린 네트워크
        - 버퍼를 이용한 해결
            - 입출력 소스와 직접 작업하지 않고 버퍼(buffer)와 작업 - 실행 성능 향상
            - 프로그램은 쓰기 속도 향상
            - 버퍼 차게 되면 데이터를 한꺼번에 하드 디스크로 보내 출력 횟수를 줄여줌
        - BufferedInputStream, BufferedReader
        - BufferedOutputStream 과 BufferedWriter
    - 기본 타입 입출력 보조 스트림 - 입출력 순서를 맞추어 사용
    
    ![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/a34d13ac-ba3a-448f-9b2e-c414d1fa5da7/Untitled.png)
    
    - 프린터 보조 스트림
    
    ![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/4d3e7e29-748e-42fe-a6e0-fe0e6950506b/Untitled.png)
    
    - 객체 입출력 보조 스트림
        - 객체를 파일 또는 네트워크로 입출력할 수 있는 기능 제공
        - 객체 직렬화 : 객체는 문자가 아니므로 바이트 기반 스트림으로 데이터 변경 필요
        - ObjectInputStream, ObjectOutputStream
        - 직렬화가 가능한 클래스 (Serializable)
            - 자바에서는 Serializable 인터페이스를 구현한 클래스만 직렬화 할 수 있도록 제한, transient 필드는 제외
            - 객체 직렬화 할 떄 private 필드 포함한 모든 필드를 바이트로 변환 가능
        - serialVersionUID 필드
            - 직렬화된 객체를 역직렬화 할 때는 직렬화 했을 때와 같은 클래스 사용
            - 클래스의 이름이 같더라도 클래스의 내용이 변경된 경우 역직렬화 실패
            - serialVersionUID
                - 같은 클래스임을 알려주는 식별자 역할
                - Serializable 인터페이스 구현 : 컴파일시 자동적으로 serialVersinonUID 정적 필드 추가
                - 재컴파일 하면 serialVersionUID 값 변경
            - 불가피한수정 있을 경우 명시적으로 serialVersionUID 선언
        - writeObject()와 readObject()메소드
            - writeObject(ObjectOutputStream out)
                - 직렬화 직전 자동 호출, 추가질렬화할 내용 작성 가능
            - readObject(ObjectInputStream in)
                - 역직렬화 직전 자동호출 , 추가 역질렬화 내용 작성 가능
            - 추가 직렬화 및 역직렬화 필요한 경우
                - 부모 클래스가 Serializable 구현하지 않고, 자식 클래스가 Serializable 구현한 경우
                - 부모 필드는 직렬화에서 제외
                - writeObject() 에서 부모 필드 직렬화 필요
                - readObject() 에서 부모필드 역직렬화 필요
                - 부모 클래스가 Serializable 구현하도록 하는게 제일 쉬움