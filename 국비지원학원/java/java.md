# Java

## Java API문서의 설치

- Java API란?

    -Java로 프로그램을 만드는데 필요한 주요 기능을 미리 만들어서 제공

- Java API문서란?

    -JavaAPI가 제공하는 기능에 대한 상세한 정보 제공(html파일)

- JavaAPI 문서의 설치

    -[여기](https://www.oracle.com/)에서 압축파일을 다운받아서 압축해제

## 이클립스에서 자바 프로그램을 작성하는 순서

1. 프로젝트를 생성한다
    * 메뉴 File>New>Java Project
2. 클래스를 생성한다.
    * 프로젝트 이름 위에서 우클릭 > New > Class
3. 소스파일의 작성 후 저장(자동 컴파일됨)
4. 실행
    * 메뉴 Run > Run

## Build 관련 메뉴 설명

- Build란?
    * 소스파일로부터 프로그램을 만들어 내는 전 과정
- Project > Build AII
    * workspace의 모든 프로젝트를 빌드
- Project > Build Project
    * 현재 프로젝트를 빌드(변경된 소스 파일만 새로 컴파일)
- Project > Clean
    * 이전 빌드의 정보를 모두 삭제(모든 소스 파일을 새로 컴파일)
    * 간혹가다 프로그램이 아무런 이유없이 실행되지 않을때 clean후 재컴파일
- Project > Build Automatically
    * 소스 파일을 변경 후, 저장할때마다 자동 컴파일

## 이클립스 기본 단축키

- ctrl + shift + l // 단축키 전체목록 보기
- ctrl + d // 한줄 삭제
- ctrl+ +,- // 폰트 크기 증가/감소
- ctrl + alt + down //행단위 복사
- alt + shift + A // 멀티 컬럼편집
- alt + up, down // 행단위 이동
- ctrl+i // 자동 들여쓰기
- ctrl + / // 주석 처리 (토글)
- ctrl + space // 자동완성

## 변수

1. 변수(variable)란?
    1. 하나의 값(데이터)을 저장할 수 있는 메모리 공간
2. 변수의 선언
    1. 변수의선언이유
        1. 값을 저장할 공간을 마련하기 위해서
    2. 변수의 선언 방법
        1. 변수타입 변수이름;
        2. ex) int age; //정수 타입의 변수 age를 선언
        3. age에 메모리 공간이 생성됨
3. 변수에 값 저장하기
    1. int age =25; // 정수 타입의 변수 age를 선언 하고 age에 25를 저장
    2. 변수의 초기화 // 변수에 처음으로 값을 저장하는것
        1. 지역 변수는 읽기전에 꼭 초기화 해야함!
4. 변수의 값 읽어오기 
    1. 변수의 값이 필요한 곳에 변수의 이름을 적는다
5. 변수의 이름 생성  // 변수 이름은 중복 불가
6. 변수의 타입
    1. int : 정수타입 , 여기에 실수 저장하려하면 에러남
    2. 변수의 타입은 저장할 값의 타입에 의해 결정된다
    3. 저장할 값의 타입과 일치하는 타입으로 변수를 선언
7. 값의 타입
    
    기본형//기본형을 제외한 나머지는 전부다 참조변수임
    
    1. 문자 : char : 2byte의 저장공간 65536가지의 값 표현
        1. 홑따옴표 = 한개의 문자 문자열
        2. 쌍따옴표 = 긴 문자열
    2. 숫자
        1. 정수 : 
            1. byte : 1byte의 저장 공간 -128 ~ 0 ~ 127
            2. short : 2byte의 저장공간 65536가지의 값 표현
            3. int : 4byte 정수
            4. long : 8byte 정수 8바이트 공간에 저장하라는 의미로 L을 붙임
        2. 실수 : 
            1. float : 소수점 7자리, 4바이트를 사용해도 충분한 실수인지 F를 붙임
            2. double : 소수점 15자리 - 실수 형 기본 리터럴
    3. 논리 : boolean 
        1. true : 1byte에 논리값을 저장
        2. false : 1byte에 논리값을 저장
    
    문자열 저장하는 녀석
    
    1. String : API CLASS 임, char type으로 저장됨, String 역시 참조변수
    2. new String("") : new라는 연산자는 heap에 동적으로 할당됨
8. 변수, 상수, 리터럴
    1. 상수(constant) : 한 번만 값을 저장 가능한 변수
    2. 리터럴(literal) : 그 자체로 값을 의미하는 것
9. 리터럴의 접두사와 접미사
    1. 논리형 
    2. 정수형
    3. 실수형
    4. 문자형
    5. 문자열
10. 문자와 문자열
    1. 

 

## 주석과 실행문

- 주석문 : 프로그램 실행과는 상관없이 코드에 설명 붙인것, 컴파일 과정에서 주석은 무시되고 실행문만 바이트 코드로 번역
    - // : 행주석
    - /* ~ */ : 범위 주석
- 실행문 : 변수 선언 값 저장 , 메소드 호출에 해당하는 코드 실행문 끝에는 반드시 세미콜론(;)을 붙여 실행문의 끝 표시

## 단항 연산자

- 단항연산자 : 피연산자가 1개인 연산자
    - 부호 연산자 : +, - //boolean 타입과 char 타입을 제외한 기본타입에 사용 가능 , 부호 연산자의 산출 타입은 int
    - 증감 연산자 : ++, — // 변수의 값을 1증가 시키거나 1감소 시키는 연산자, 증감 연산자가 변수 뒤에 있으면 다른 연산자 먼저 처리 후 증감 연산자 처리
    - 논리 부정 연산자 : ! // Boolean type 에만 사용가능

## 산술 연산자

- 산술 연산자 : +, -, *, /, %
- 문자열 연산자 : 피연산자중 문자열이 있으면 문자열로 결합 // 연산은  기본적으로 좌측부터 우측으로 진행 // 대입연산은 우측에서 좌측으로 진행
- 비교 연산자 : 동등 비교연산자는 모든 타입에 사용 가능 , 크기 비교 연산자는 boolean 타입 제외한 모든 기본타입에 사용 가능, 제어문인 조건문(if), 반복문(for, while)에서 주로 이용
    - ==, !=, > , >=, <, <=
    - 기본적으로 stack에 있는 값을 비교하기 때문에 주의하자
- 논리 연산자
    - &&, ||, ^, ! : 좌측에서 이미 값을 만족해버리면 우측은 연산조차 안되니 주의할것!
    - && : 논리곱 둘다 true(참) 일떄만 참, 둘중 하나라도 만족하지 못하면 false
    - || : 하나라도 참이면 참, 둘다 거짓일때 거짓
    - ^ : 베타 연산자, 둘의 논리 값이 서로 달라야 true, 같으면 false
    - ! : 논리부정
- 비트 연산자
    - <<, >>, >>> : bit값을 제어하는 연산자
- 연산의 방향과 우선순위
    - *, /, % 는 같은우선순위 왼쪽에서 오른쪽으로 수행
        - 산술, 쉬프트,비교,논리,조건 (연산방향 좌에서 우)
    - 단항,부호,대입 연산자는 오른쪽에서 왼쪽으로 연산
        - 증감,대입 ( 연산방향 우에서 좌)

## 제어문

제어문의 종류

- 조건문
    - if문, switch문
    - if 문 : 조건식 결과에 따라 중괄호 블록을 실행할지 여부를 결정
        - 조건식 : true 또는 false값을 산출할수 있는 연산식, 조건식이 true이면 블록을 실행, false이면 실행하지 않음
    - if else 문 : 조건식 결과에 따라 실행 블록 선택
    - if-else if-else 문 : 복수의 조건식을 두어 조건식을 만족하는 블록만 실행
    - switch문 : 변수나 연산식의 값에 따라 실행문을 선택할 때 사용
- 삼항연산자 : 세 개의 피연산자를 필요로 하는
    - 연산자 앞의 조건식 결과에 따라 콜론 앞 뒤의 피연산자 선택 → 조건 연산식
    - 조건식 ? 값또는 연산식(true) : 값 또는 연산식(false)
- 반복문 : 중괄호 블록 내용을 반복적으로 실행할 때 사용
    - for문, while문, do-while문
    - for문 : 주로 반복 횟수를 알고있을때 사용
    - while문 : 조건에 따라 반복을 계속할지 결정할 때 사용
    - do-while문 : do{실행문} while{조건식} // 조건에 따라 반복할지결정하는건 while문과 동일, 무조건 중괄호 블록을 한 번 실행한 후, 조건 검사후 반복 결정
- break문, continue문
    - break문 : for문, while문, do-while문, switch문 종료(반복 취소), 대개 if문과 같이 사용
    - break문 (반복문이 중첩된 경우) : 가장 가까운 반복문만 종료, 바깥쪽 까지 종료시키려면 반복문에 이름을 붙이고 "break 이름;" 사용
    - continue 문 : for문, while문, do-while문에서 사용
        - for문 : 증감식으로 바로이동
        - while, do- while문 : 조건식으로 바로이동
- 제어문의 중첩 : 제어문의 중괄호 내부에 다른 제어문 작성 가능 , 다양한 흐름 발생가능

## 데이터 타입 분류

- 기본타입(primitive type) : 상단참조
- 참조 타입(reference type)
    - 배열 타입
    - 열거 타입
    - 클래스
    - 인터페이스

## 데이터 타입 변환

- 타입 변환 : 데이터 타입을 다른 타입으로 변환하는 것
    - 자동(묵시적)타입 변환:Promotion // 값의 변경이 일어날 위험성이 없는것을 컴파일러가 자동으로 변경해주는것
    - 강제(명시적)타입 변환:Casting
- 자동 타입 변환 : 프로그램 실행 도중 작은 타입은 큰 타입으로 자동 타입 변환 가능
    - byte(1)<\short(2)<\int(4)<\long(8)<\float(4)<\double(8)
- 강제 타입 변환 : 큰 타입을 작은 타입 단위로 쪼개기, 끝의 한 부분만 작은 타입으로 강제적 변환

## 메모리 사용 영역

- 변수의 메모리 사용
    - 기본 타입 변수 : 실제 값을 변수 안에 저장
    - 참조 타입 변수 : 주소를 통해 객체(heap영역) 참조 // . 을통해 이동~
- JVM이 사용하는 메모리 영역 : OS에서 할당 받은 메모리 영역(Runtime ,Data, Area)을 세 영역으로 구분
    - 메소드 영역(Method Area)
    - 힙 영역(Heap Area)
    - JVM 스택(Stack)

## 참조 변수의 == , != 연산

- 변수의 값이 같은지 다른지 비교
    - 기본 타입 : 변수의 값이 같은지 다른지 조사
    - 참조 타입 : 동일한 객체를 참조하는지 다른객체를 참조하는지 조사

## null 과 nullPointerException

- null(널)
    - 변수가 참조하는 객체가 없을 경우 초기값으로 사용 가능
    - 참조타입 변수에만 저장가능
    - null 로 초기화된 참조 변수는 스택 영역 생성
    - ==, !=연산 가능
- NullPointerException의 의미
    - 예외(Exception) : 사용자의 잘못된 조작이나 잘못된 코딩으로 인해 방생하는 프로그램 오류
    - NullPointerException : 참조 변수가 null 값을 가지고 있을 때 객체의 필드나 메소드를 사용하려고 했을 때 발생

## String 타입

- String 타입
    - 문자열을 저장하는 클래스 타입
    - 문자열 리터럴 동일하다면 String 객체 공유
    - new 연산자를 이용한 String 객체 생성
        - 힙 영역에 새로운 String 객체 생성
        - String 객체를 생성한 후 번지 리턴

## 배열 타입

- 배열이란? : 같은타입의 데이터를 연속된 공간에 저장하는 자료구조, 각데이터 저장 위치는 인덱스 부여해 접근
- 배열의 장점 : 중복된 변수 선언 줄이기 위해 사용, 반복문 이용해 요소들을 쉽게 처리
- 배열 선언 : 배열을 사용하기 위해 우선 배열 변수 선언
    - 타입[] 변수;
    - 타입 변수[];
    - 배열 변수는 참조 변수 - 배열 생성되기 전 null로 초기화 가능
    - 배열 변수가 null  값을 가진 상태에서 항목에 접근 불가
    - 데이터타입[] 변수 = {값 0, 값 1, 값 2, ...} //선언과 동시에 값 목록 대입
    - 데이터 타입 [] 변수;
    - 변수 = new 타입[] {값 0, 값 1, 값 2, 값 3, ...} // 변수 선언 후 값 목록 대입
- 배열의 길이
    - 배열변수.length;
    - 배열의 길이는 읽기 전용
    - 배열의 길이는 for문에서 조건식으로 주로 사용
- 다차원 배열
    - 2차원 배열 이상의 배열(행렬과 같은 자료구조)
- 객체를 참조하는 배열
    - 기본타입 배열은 각항목에 직접 값을 가지는 반면
    - 참조 타입 배열은 각항목에 객체의 주소를 가진다
- 향상된 for문
    - for(타입변수 : 배열){실행문}
    - 배열 및 컬렉션의 항목 요소를 순차적으로 처리
    - 인덱스 이용하지 않고 바로 항목 요소 반복
        
        

## class

- 객체 지향 프로그래밍
    - OOP:Object Oreiented Programming : 부품객체를 먼저 만들고 이것들을 하나씩 조립해 완성된 프로그램을 만드는 기법
    - 객체란? : 물리적으로 존재하는것, 추상적인것 중에서 자신의 속성과 동작을 가지는 모든것 , 객체는 필드(속성) 과 메소드(동작)로 구성된 자바 객체로 모델링 가능
    - 객체의 상호 작용 : 객체들은 서로간에 기능(동작)을 이용하고 데이터를 주고 받음
    - 객체 간의 관계 : 객체 지향 프로그램에서는 객체는 다른 객체와 관계를 맺음
        - 집합 관계 : 완성품과 부품의 관계
        - 사용 관계 : 객체가 다른 객체를 사용하는 관계
        - 상속 관계 : 종류 객체와 구체적인 사물 객체 관계
- 객체지향 프로그래밍의 특징
    - 캡슐화
    - 상속
    - 다형성
- 객체와 클래스
    - 설계도 → 객체
    - 클래스 → 객체
    - 클래스에는 객체를 생성하기 위한 필드와 메소드가 정의
    - 클래스로부터 만들어진 객체를 해당 클래스의 인스턴스(instance)
    - 하나의 클래스로 부터 여러개의 인스턴스를 만들 수 있음
- 클래스의 이름
    - 자바 식별자 작성 규칙에 따라야
        1. 하나 이상의 문자로 이루어져야 한다.
        2. 첫 번째 글자는 숫자가 올 수 없다.
        3. $,  _ 외의 특수문자 사용할 수 없다
        4. 자바 키워드는 사용할 수 없다.
    - 한글 이름도 가능하나, 영어로 작성
    - 알파벳 대소문자는 서로 다른 문자로 인식
    - 첫 글자와 연결된 다른 단어의 첫 글자는 대문자로 작성하는 것이 관례
    - 이름 길이의 제한은 없지만 24자 이하로 작성하자
- 클래스 선언과 컴파일
- new 연산자 : 객체 생성 역할 // 동적할당
    - new 클래스(); // 우리가 필요한 공간(데이터 타입)을 파악하고 그공간의 위치를 알려주는 역할
    - 생성된 객체는 힙 메모리 영역에 생성
    - new 연산자는 객체를 생성 후, 객체 생성 번지 리턴
- 클래스 변수 : new 연산자에 의해 리턴 된 객체의 번지 저장 (참조 타입 변수), 힙 영역의 객체를 사용하기 위해 사용
- 클래스의 용도
    - 라이브러리(API) 용 : 자체적으로 실행되지 않음, 다른 클래스에서 이용할 목적으로 만든 클래스
    - 실행용 : main() 메소드를 가지고 있는 클래스로 실행할 목적으로 만든 클래스
    - 1개의 애플리케이션 = (1개의 실행 클래스)+ (n 개의 라이브러리 클래스)
- 클래스의 구성 멤버
    - 필드(Field) : 객체의 데이터가 저장되는 곳
    - 생성자(Constructor) : 객체 생성시 초기화 역할 담당
    - 메소드(Method) : 객체의 동작에 해당하는 실행 블록 // 일반적으로 함수랑 같다고 생각하세요
- 필드의 내용
    - 객체의 고유 데이터 // 고정된 데이터값
    - 객체가 가져야 할 부품 객체
    - 객체의 현재 상태 데이터 // 변경될수 있는값
- 필드의 기본 초기값
    - 초기값 지정되지 않은 필드 : 객체 생성시 자동으로 기본값으로 초기화
- 필드  사용
    - 필드 값을 읽고, 변경하는 작업을 말한다
    - 필드 사용 위치
        - 객체 내부 : "필드이름" 으로 바로 접근
        - 객체 외부 : "변수.필드이름" 으로  접근
- 생성자 : new 연산자에 의해 호출되어 객체의 초기화 담당
    - 필드의 값 설정
    - 메소드 호출해 객체를 사용할 수 있도록 준비하는 역할 수행
- 기본 생성자(Default Constructor) : 모든 클래스는 생성자가 반드시 존재하며 하나 이상 가질수 있음, 생성자 선언을 생략하면 컴파일러는 다음과 같은 기본 생성자 추가
- 생성자 선언
    - 디폴트 생성자 대신 개발자가 직접 선언
    - 개발자가 선언한 생성자 존재시 컴파일러는 기본 생성자를 추가하지 않음 : new 연산자로 객체 생성시 개발자가 선언한 생성자 반드시 사용
- 필드 초기화 : 초기값 없이 선언된 필드는 객체가 생성될 떄 기본값으로 자동 설정
    - 다른값으로 필드 초기화 하는 방법
        - 필드 선언할 떄 초기값 설정
        - 생성자의 매개값으로 초기값 설정
    - 매개 변수와 필드명 같은경우 this 사용
- 생성자 다양화 해야하는 이유 : 객체 생성할 때 외부 값으로 객체를 초기화 할 필요, 외부 값이 어떤 타입으로 몇개가 제공될지 모름 -생성자도 다양화
    - 생성자 오버로딩(Overloading) : 매개변수의 타입, 개수, 순서가 다른 생성자 여러 개 선언
    - 다른 생성자 호출( this() ) : 생성자 오버로딩 되면 생성자 간의 중복된 코드 발생 , 초기화 내용이 비슷한 생성자들 에서 이러한 현상을 많이 볼수 있음
        - 초기화 내용을 한 생성자에 몰아 작성
        - 다른 생성자는 초기화 내용을 작성한 생성자를 this()로 호출

## 메소드

- 메소드란? : 객체의 동작(기능), 호출해서 실행할 수 있는 중괄호 {} 블록, 메소드 호출하면 중괄호 {} 블록에 있는 모든 코드들이 일괄 실행
- 메소드 선언 : 리턴타입 메소드이름([매개변수선언, ...]) {실행할 코드}
    - 메소드 리턴 타입 : 메소드 실행된 후 리턴하는 값의 타입, 메소드는 리턴값이 있을 수도 있고 없을 수도 있음  // 함수의 종료를 뜻하기도 한다
        - void = 반환값이 없다 는 뜻 ~ 그냥 함수가 실행만 됨
    - 메소드 이름 : 자바 식별자 규칙에 맞게 작성
    - 메소드 매개변수 선언 : 매개변수는 메소드를 실행할 떄 필요한 데이터를 외부에서 받기 위해 사용, 매개변수도 필요 없을 수 있음  // 매개변수도 타입을 지정해서 사용해야함 안그럼오류
- 리턴(return) 문
    - 메소드 실행을 중지하고 리턴값 지정하는 역할
    - 리턴 값이 있는 메소드 : 반드시 리턴문 사용해 리턴값 지정해야
    - 리턴 값이 없는 메소드 : 메소드 실행을 강제 종료 시키는 역할
- 메소드 호출 : 메소드는 클래스 내-외부의 호출에 의해 실행
    - 클래스 내부 ; 메소드 이름으로 호출
    - 클래스 외부 : 객체 생성 후, 참조 변수를 이용해 호출
- 메소드 오버로딩 : 클래스 내에 같은 이름의 메소드를 여러 개 선언하는 것
    - 하나의 메소드 이름으로 다양한 매개값 받기 위해 메소드 오버로딩
    - 오버로딩의 조건 : 매개변수의 타입, 개수, 순서가 달라야
    

## 인스턴스 멤버와 this

- 인스턴스 멤버란?
    - 객체(인스턴스) 마다 가지고 있는 필드와 메소드 : 이들을 각각 인스턴스 필드, 인스턴스 메소드라고 부름
    - 인스턴스 멤버는 객체 소속된 멤버 이기 떄문에 객체가 없이 사용불가
- this
    - 객체(인스턴스) 자신의 참조(번지)를 가지고 있는 키워드
    - 객체 내부에서 인스턴스 멤버임을 명확히 하기 위해 this. 사용
    - 매개변수와 필드명이 동일할 때 인스턴스 필드임을 명확히 하기 위해 사용